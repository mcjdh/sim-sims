<!DOCTYPE html>
<html>
<head>
    <title>Quantum Neural Lattice</title>
    <style>
        body {
            background: #000814;
            color: #aaeeff;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1.0;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas {
            white-space: pre;
            font-feature-settings: 'kern' 0;
            text-align: center;
            text-shadow: 0 0 3px rgba(170, 238, 255, 0.6), 0 0 10px rgba(170, 238, 255, 0.3);
            filter: blur(0.08px) brightness(1.2);
            transition: all 0.3s ease;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 11px;
            color: #88ddff;
            background: rgba(0, 20, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4488ff;
            max-width: 250px;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            color: #66ccff;
            font-weight: bold;
        }

        .stat-value {
            color: #ffee88;
        }

        .emergence-high {
            color: #ffaa44;
            text-shadow: 0 0 5px #ff8844;
        }
    </style>
</head>
<body>
    <div id="stats">
        <div class="stat-label">Quantum Neural Lattice</div>
        <div style="margin-top: 10px;">
            Nodes: <span class="stat-value" id="nodeCount">0</span><br>
            Coherence: <span class="stat-value" id="coherence">0%</span><br>
            Emergence: <span class="stat-value" id="emergence">0.00</span><br>
            Resonance: <span class="stat-value" id="resonance">0.00</span><br>
            Connections: <span class="stat-value" id="connections">0</span>
        </div>
    </div>
    <div id="canvas"></div>
    <script>
        const W = 120, H = 60;
        let time = 0;

        // Quantum neural nodes with wave properties
        class QuantumNode {
            constructor(x, y, frequency) {
                this.x = x;
                this.y = y;
                this.frequency = frequency;
                this.phase = Math.random() * Math.PI * 2;
                this.amplitude = 0.5 + Math.random() * 0.5;
                this.connections = [];
                this.activation = 0;
                this.quantumState = { real: 0, imag: 0 };
                this.coherence = 0;
                this.entangled = null;
            }

            update(time, nodes) {
                // Quantum wave function evolution
                const wavePhase = this.frequency * time * 0.01 + this.phase;
                this.quantumState.real = this.amplitude * Math.cos(wavePhase);
                this.quantumState.imag = this.amplitude * Math.sin(wavePhase);

                // Neural activation from connected nodes
                let totalActivation = 0;
                for (let conn of this.connections) {
                    const otherNode = nodes[conn.targetId];
                    if (otherNode) {
                        // Quantum interference between nodes
                        const dx = this.x - otherNode.x;
                        const dy = this.y - otherNode.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const phaseDiff = wavePhase - (otherNode.frequency * time * 0.01 + otherNode.phase);

                        // Constructive/destructive interference
                        const interference = Math.cos(phaseDiff) * Math.exp(-dist * 0.02);
                        totalActivation += interference * conn.weight * otherNode.amplitude;
                    }
                }

                // Smooth activation with quantum influence
                this.activation = this.activation * 0.9 + totalActivation * 0.1;

                // Coherence based on phase alignment
                const probDensity = this.quantumState.real * this.quantumState.real +
                                   this.quantumState.imag * this.quantumState.imag;
                this.coherence = Math.tanh(probDensity + Math.abs(this.activation) * 0.5);

                // Entanglement effects
                if (this.entangled && Math.random() < 0.1) {
                    const partner = nodes[this.entangled];
                    if (partner) {
                        // Quantum correlation
                        this.amplitude = (this.amplitude + partner.amplitude) * 0.5;
                        const avgPhase = (this.phase + partner.phase) * 0.5;
                        this.phase = avgPhase;
                        partner.phase = avgPhase + Math.PI; // Anti-correlation
                    }
                }

                // Spontaneous frequency modulation from activation
                this.frequency = this.frequency + this.activation * 0.001;
                this.frequency = Math.max(0.5, Math.min(3.0, this.frequency));
            }
        }

        // Initialize quantum neural lattice
        let nodes = [];
        const gridSize = 8;
        let nodeId = 0;

        for (let gy = 0; gy < gridSize; gy++) {
            for (let gx = 0; gx < gridSize; gx++) {
                const x = (W / (gridSize + 1)) * (gx + 1);
                const y = (H / (gridSize + 1)) * (gy + 1);
                const frequency = 0.8 + Math.random() * 1.4;
                nodes.push(new QuantumNode(x, y, frequency));
            }
        }

        // Create neural connections with quantum entanglement
        function createConnections() {
            let connectionCount = 0;
            let entanglementCount = 0;

            for (let i = 0; i < nodes.length; i++) {
                // Connect to nearby nodes
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;

                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    // Probability of connection decreases with distance
                    if (Math.random() < Math.exp(-dist * 0.08)) {
                        const weight = (Math.random() - 0.5) * 2; // Can be positive or negative
                        nodes[i].connections.push({
                            targetId: j,
                            weight: weight
                        });
                        connectionCount++;
                    }
                }

                // Random entanglement
                if (!nodes[i].entangled && Math.random() < 0.15) {
                    const candidates = nodes.filter((n, idx) => idx !== i && !n.entangled);
                    if (candidates.length > 0) {
                        const partner = candidates[Math.floor(Math.random() * candidates.length)];
                        const partnerId = nodes.indexOf(partner);
                        nodes[i].entangled = partnerId;
                        partner.entangled = i;
                        entanglementCount++;
                    }
                }
            }

            return { connections: connectionCount, entanglements: entanglementCount };
        }

        const connStats = createConnections();

        // Quantum field arrays
        let waveField = new Float32Array(W * H);
        let interferenceField = new Float32Array(W * H);
        let activationField = new Float32Array(W * H);

        // Symbol palette for different intensities
        const symbols = ' .·:∘○◌◍◎◉⊙⊚⊛⊜⊝✦✧✨✩✪✫✬✭✮✯✰✱✲✳✴✵✶✷✸✹✺';

        // Calculate quantum wave interference field
        function calculateFields() {
            // Clear fields
            waveField.fill(0);
            interferenceField.fill(0);
            activationField.fill(0);

            // Calculate wave contributions from each node
            for (let node of nodes) {
                const nodeWaveNumber = node.frequency * 0.5;

                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = y * W + x;

                        // Distance from node
                        const dx = x - node.x;
                        const dy = y - node.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist < 50) { // Optimization: limit range
                            // Quantum wave propagation
                            const wavePhase = nodeWaveNumber * dist - node.frequency * time * 0.01 + node.phase;
                            const envelope = Math.exp(-dist * 0.08) * node.amplitude;

                            // Wave function contribution
                            const waveContrib = envelope * Math.cos(wavePhase);
                            waveField[idx] += waveContrib;

                            // Interference pattern (phase-sensitive)
                            const interferenceContrib = envelope * Math.sin(wavePhase) * node.coherence;
                            interferenceField[idx] += interferenceContrib;

                            // Neural activation spread
                            const activationContrib = Math.exp(-dist * 0.15) * node.activation * 2;
                            activationField[idx] += activationContrib;
                        }
                    }
                }
            }
        }

        // Update statistics
        function updateStats() {
            let totalCoherence = 0;
            let maxEmergence = 0;
            let totalResonance = 0;

            for (let node of nodes) {
                totalCoherence += node.coherence;
                const emergence = Math.abs(node.activation);
                maxEmergence = Math.max(maxEmergence, emergence);
                totalResonance += Math.abs(node.quantumState.real) + Math.abs(node.quantumState.imag);
            }

            const avgCoherence = totalCoherence / nodes.length;
            const avgResonance = totalResonance / (nodes.length * 2);

            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('coherence').textContent = (avgCoherence * 100).toFixed(1) + '%';
            document.getElementById('emergence').textContent = maxEmergence.toFixed(3);
            document.getElementById('resonance').textContent = avgResonance.toFixed(3);
            document.getElementById('connections').textContent = connStats.connections;

            // Highlight high emergence
            const emergenceElem = document.getElementById('emergence');
            if (maxEmergence > 0.5) {
                emergenceElem.className = 'stat-value emergence-high';
            } else {
                emergenceElem.className = 'stat-value';
            }
        }

        // Render function
        function render() {
            // Update all nodes
            for (let node of nodes) {
                node.update(time, nodes);
            }

            // Calculate quantum fields
            calculateFields();

            // Update stats
            updateStats();

            // Build visualization
            let output = '';
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;

                    // Combine fields
                    const wave = waveField[idx];
                    const interference = interferenceField[idx];
                    const activation = activationField[idx];

                    // Composite intensity with quantum breathing
                    const breath = Math.sin(time * 0.003) * 0.15 + 0.85;
                    let intensity = (wave * 0.3 + interference * 0.3 + activation * 0.4) * breath;

                    // Add global field oscillation
                    const globalPhase = Math.sin(x * 0.05 + time * 0.005) * Math.cos(y * 0.04 + time * 0.004);
                    intensity += globalPhase * 0.1;

                    // Normalize to [0, 1]
                    intensity = (intensity + 1.5) / 3.0;
                    intensity = Math.max(0, Math.min(1, intensity));

                    // Draw nodes as bright spots
                    let isNode = false;
                    for (let node of nodes) {
                        const dx = x - node.x;
                        const dy = y - node.y;
                        if (Math.abs(dx) < 1 && Math.abs(dy) < 0.5) {
                            // Node position - make it bright and pulsing
                            const nodePulse = Math.sin(node.frequency * time * 0.02 + node.phase) * 0.3 + 0.7;
                            intensity = Math.max(intensity, nodePulse);
                            isNode = true;
                            break;
                        }
                    }

                    // Map to symbol
                    const symbolIndex = Math.floor(intensity * (symbols.length - 1));
                    output += symbols[Math.max(0, Math.min(symbols.length - 1, symbolIndex))];
                }
                output += '\n';
            }

            document.getElementById('canvas').textContent = output;
            time++;
            requestAnimationFrame(render);
        }

        // Start the quantum neural lattice
        render();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                // Add spontaneous quantum fluctuation
                const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                randomNode.amplitude += (Math.random() - 0.5) * 0.3;
                randomNode.amplitude = Math.max(0.1, Math.min(1.5, randomNode.amplitude));
            }
        });

        console.log('Quantum Neural Lattice initialized');
        console.log(`Nodes: ${nodes.length}, Connections: ${connStats.connections}, Entanglements: ${connStats.entanglements}`);
    </script>
</body>
</html>
