<!DOCTYPE html>
<html>
<head>
    <title>probability gardens</title>
    <style>
        body {
            background: black;
            color: #aaffaa;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 0.9;
            letter-spacing: 0px;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        #canvas {
            white-space: pre;
            font-feature-settings: 'kern' 0;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <script>
        const W = 135, H = 65;
        let time = 0;
        
        // Probability ecosystem fields
        let probabilityField = new Array(W * H).fill(0);
        let branchingField = new Array(W * H).fill(0);
        let growthField = new Array(W * H).fill(0);
        let decayField = new Array(W * H).fill(0);
        let quantumSoil = new Array(W * H).fill(0);
        
        // Reality seeds - points where possibilities crystallize
        let realitySeeds = [
            { x: 25, y: 20, probability: 0.8, branches: 0, growth: 0, species: 'memory' },
            { x: 70, y: 15, probability: 0.6, branches: 0, growth: 0, species: 'choice' },
            { x: 110, y: 30, probability: 0.9, branches: 0, growth: 0, species: 'dream' },
            { x: 45, y: 45, probability: 0.7, branches: 0, growth: 0, species: 'fear' },
            { x: 85, y: 50, probability: 0.5, branches: 0, growth: 0, species: 'hope' }
        ];
        
        // Probability storms - quantum fluctuation events
        let probabilityStorms = [];
        
        // Garden symbols: void → seed → sprout → branch → bloom → fruit → decay
        const symbols = ' ·∘○◯⚬⚭⚮⚯⛤⛥⛦⛧⛨⛩⛪⛫⛬⛭⛮⛯⛰⛱⚘❀❁❂❃❄❅❆❇❈❉❊❋';
        
        function quantumFluctuation(x, y, time) {
            // Heisenberg uncertainty creating probability fluctuations
            const momentum = Math.sin(x * 0.15 + time * 0.01);
            const position = Math.cos(y * 0.12 - time * 0.008);
            
            // Uncertainty relation ΔxΔp ≥ ℏ/2
            const uncertainty = Math.abs(momentum * position) * 0.5;
            
            // Vacuum fluctuations
            const vacuum = (Math.random() - 0.5) * 0.1 * Math.exp(-time * 0.0001);
            
            return uncertainty + vacuum;
        }
        
        function probabilityBranching(x, y, seed, time) {
            const dx = x - seed.x;
            const dy = y - seed.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Growth emanating from seed
            seed.growth = Math.min(seed.growth + 0.015, 40);
            
            if (dist > seed.growth) return 0;
            
            // Branching patterns based on species
            let branchPattern = 0;
            const angle = Math.atan2(dy, dx);
            
            switch(seed.species) {
                case 'memory':
                    // Dendritic branching like neurons
                    branchPattern = Math.sin(angle * 3 + dist * 0.2 + time * 0.01);
                    break;
                case 'choice':
                    // Binary branching decisions
                    branchPattern = Math.sign(Math.sin(angle * 2 + time * 0.005)) * Math.cos(dist * 0.15);
                    break;
                case 'dream':
                    // Chaotic, organic growth
                    branchPattern = Math.sin(angle * 5 + dist * 0.3) * Math.sin(time * 0.02 + dist * 0.1);
                    break;
                case 'fear':
                    // Retracting, withering patterns
                    branchPattern = -Math.abs(Math.sin(angle * 4 - time * 0.015)) * Math.exp(-dist * 0.08);
                    break;
                case 'hope':
                    // Reaching upward, light-seeking
                    branchPattern = Math.max(0, Math.sin(angle - Math.PI/2) * Math.cos(dist * 0.1 + time * 0.008));
                    break;
            }
            
            // Probability amplitude decay with distance
            const amplitude = Math.exp(-dist * 0.05) * seed.probability;
            
            // Quantum interference between branches
            const interference = Math.sin(dist * 0.4 + time * 0.03 + seed.probability * Math.PI);
            
            return branchPattern * amplitude * (1 + interference * 0.3);
        }
        
        function manyWorldsInterference(x, y, time) {
            // Multiple realities interfering with each other
            let interference = 0;
            
            for (let i = 0; i < realitySeeds.length; i++) {
                for (let j = i + 1; j < realitySeeds.length; j++) {
                    const seed1 = realitySeeds[i];
                    const seed2 = realitySeeds[j];
                    
                    const dx1 = x - seed1.x;
                    const dy1 = y - seed1.y;
                    const dx2 = x - seed2.x;
                    const dy2 = y - seed2.y;
                    
                    const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                    const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    
                    // Phase difference between realities
                    const phaseDiff = (dist1 - dist2) * 0.2 + time * 0.01;
                    
                    // Constructive/destructive interference
                    const interferenceTerm = Math.cos(phaseDiff) * 
                                           Math.exp(-(dist1 + dist2) * 0.02) * 
                                           seed1.probability * seed2.probability;
                    
                    interference += interferenceTerm;
                }
            }
            
            return interference * 0.2;
        }
        
        function waveFunction(x, y, time) {
            // Schrödinger equation evolution
            const ψ_real = Math.sin(x * 0.1 + time * 0.005) * Math.cos(y * 0.08 - time * 0.007);
            const ψ_imag = Math.cos(x * 0.12 - time * 0.006) * Math.sin(y * 0.09 + time * 0.004);
            
            // Probability density |ψ|²
            const probabilityDensity = ψ_real * ψ_real + ψ_imag * ψ_imag;
            
            return probabilityDensity;
        }
        
        function gardenEcosystem(x, y, time) {
            // Nutrient cycles in probability space
            const nutrients = Math.sin(x * 0.05 + time * 0.002) * Math.cos(y * 0.07 - time * 0.003);
            
            // Competition between probability species
            let competition = 0;
            for (let seed of realitySeeds) {
                const dx = x - seed.x;
                const dy = y - seed.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < seed.growth) {
                    competition += seed.probability * Math.exp(-dist * 0.1);
                }
            }
            
            // Logistic growth with carrying capacity
            const carryingCapacity = 1.5;
            const growthRate = nutrients * (1 - competition / carryingCapacity);
            
            return growthRate;
        }
        
        function probabilityCollapse(x, y, time) {
            // Quantum measurement events causing wave function collapse
            let collapse = 0;
            
            for (let storm of probabilityStorms) {
                const dx = x - storm.x;
                const dy = y - storm.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const age = time - storm.birthTime;
                
                if (age > 0 && age < storm.duration) {
                    // Collapse wave expanding from measurement
                    const radius = age * storm.speed;
                    const collapseIntensity = Math.exp(-((dist - radius) ** 2) / (2 * storm.width ** 2));
                    collapse += collapseIntensity * storm.strength;
                }
            }
            
            return collapse;
        }
        
        function render() {
            // Spontaneous quantum measurement events
            if (Math.random() < 0.006) {
                probabilityStorms.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    birthTime: time,
                    duration: 30 + Math.random() * 80,
                    speed: 0.2 + Math.random() * 0.8,
                    width: 3 + Math.random() * 12,
                    strength: 0.4 + Math.random() * 0.8
                });
            }
            
            // Remove expired storms
            probabilityStorms = probabilityStorms.filter(storm => 
                time - storm.birthTime < storm.duration
            );
            
            // Update reality seeds
            for (let seed of realitySeeds) {
                // Probability evolution
                seed.probability += (Math.random() - 0.5) * 0.01;
                seed.probability = Math.max(0.1, Math.min(1.0, seed.probability));
                
                // Branch counting
                seed.branches = Math.floor(seed.growth * 0.1);
            }
            
            // Calculate probability garden fields
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    
                    // Quantum fluctuations in the vacuum
                    const fluctuations = quantumFluctuation(x, y, time);
                    quantumSoil[idx] = fluctuations;
                    
                    // Probability branching from all seeds
                    let totalBranching = 0;
                    for (let seed of realitySeeds) {
                        totalBranching += probabilityBranching(x, y, seed, time);
                    }
                    branchingField[idx] = totalBranching;
                    
                    // Many-worlds interference
                    const interference = manyWorldsInterference(x, y, time);
                    
                    // Wave function evolution
                    const waveEvolution = waveFunction(x, y, time);
                    
                    // Ecosystem dynamics
                    const ecosystem = gardenEcosystem(x, y, time);
                    
                    // Probability collapse events
                    const collapse = probabilityCollapse(x, y, time);
                    
                    // Combined probability garden state
                    let probabilityAmplitude = branchingField[idx] + interference + waveEvolution * 0.3 + ecosystem * 0.4;
                    
                    // Collapse reduces probability superposition
                    probabilityAmplitude *= (1 - collapse * 0.7);
                    
                    // Garden breathing - universal probability pulse
                    const probabilityBreath = Math.sin(time * 0.003) * 0.2 + 0.8;
                    probabilityAmplitude *= probabilityBreath;
                    
                    // Memory with quantum decoherence
                    const decoherence = 0.89 + Math.sin(time * 0.001) * 0.04;
                    probabilityField[idx] = probabilityField[idx] * decoherence + probabilityAmplitude * (1 - decoherence);
                }
            }
            
            // Render probability gardens
            let output = '';
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    let intensity = probabilityField[idx];
                    
                    // Normalize and map to garden symbols
                    intensity = (intensity + 2) / 4;
                    intensity = Math.max(0, Math.min(1, intensity));
                    
                    const symbolIndex = Math.floor(intensity * (symbols.length - 1));
                    output += symbols[symbolIndex];
                }
                output += '\n';
            }
            
            document.getElementById('canvas').textContent = output;
            time++;
        }
        
        function evolve() {
            render();
            requestAnimationFrame(evolve);
        }
        
        evolve();
    </script>
</body>
</html> 