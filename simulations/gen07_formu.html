<!DOCTYPE html>
<html>
<head>
    <title>formula breath</title>
    <style>
        body {
            background: #000033;
            color: #ffddaa;
            font-family: 'Courier New', monospace;
            font-size: 7px;
            line-height: 0.85;
            letter-spacing: -0.3px;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            animation: mathBreath 8s infinite ease-in-out;
        }
        @keyframes mathBreath {
            0%, 100% { 
                background: #001122; 
                color: #ffeecc;
                filter: brightness(1) contrast(1);
            }
            33% { 
                background: #002211; 
                color: #eeccff;
                filter: brightness(1.05) contrast(1.1);
            }
            66% { 
                background: #112200; 
                color: #ccffee;
                filter: brightness(1.08) contrast(1.05);
            }
        }
        #canvas {
            white-space: pre;
            font-feature-settings: 'kern' 0;
            text-align: center;
            text-shadow: 0 0 1px rgba(255,221,170,0.4), 0 0 2px rgba(255,221,170,0.2);
            filter: blur(0.08px);
            transition: all 0.08s ease;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <script>
        const W = 150, H = 75;
        let time = 0;
        let mathTime = 0;
        let breathPhase = 0;
        let eleganceLevel = 0;
        
        // Mathematical breath fields - formulas as living entities
        let formulaMatrix = new Array(W * H).fill(0);
        let eulerField = new Array(W * H).fill(0);
        let goldenField = new Array(W * H).fill(0);
        let piField = new Array(W * H).fill(0);
        let waveField = new Array(W * H).fill(0);
        let infinityField = new Array(W * H).fill(0);
        
        // Living formulas - each has its own breath pattern and essence
        let livingFormulas = [
            { 
                x: W*0.2, y: H*0.2, 
                formula: 'euler', 
                essence: 'e^(iπ) + 1 = 0',
                breathRate: 0.00008, 
                depth: 5, 
                elegance: 1.0,
                meaning: 'unity of all mathematics'
            },
            { 
                x: W*0.8, y: H*0.2, 
                formula: 'golden', 
                essence: 'φ = (1+√5)/2',
                breathRate: 0.00006, 
                depth: 4, 
                elegance: 0.9,
                meaning: 'divine proportion in nature'
            },
            { 
                x: W*0.5, y: H*0.8, 
                formula: 'pi', 
                essence: 'π = ∞',
                breathRate: 0.00007, 
                depth: 6, 
                elegance: 0.95,
                meaning: 'infinite circle of existence'
            },
            { 
                x: W*0.2, y: H*0.8, 
                formula: 'wave', 
                essence: 'ψ = Ae^(ikx-iωt)',
                breathRate: 0.00009, 
                depth: 3, 
                elegance: 0.8,
                meaning: 'vibration of reality'
            },
            { 
                x: W*0.8, y: H*0.8, 
                formula: 'infinity', 
                essence: '∞ = ∞',
                breathRate: 0.00004, 
                depth: 8, 
                elegance: 1.1,
                meaning: 'boundless mystery'
            },
            { 
                x: W*0.5, y: H*0.3, 
                formula: 'unity', 
                essence: '1 = ∞/∞',
                breathRate: 0.00005, 
                depth: 7, 
                elegance: 1.05,
                meaning: 'paradox of singularity'
            },
            { 
                x: W*0.35, y: H*0.55, 
                formula: 'imaginary', 
                essence: 'i² = -1',
                breathRate: 0.0001, 
                depth: 4, 
                elegance: 0.85,
                meaning: 'impossible yet essential'
            },
            { 
                x: W*0.65, y: H*0.55, 
                formula: 'derivative', 
                essence: 'df/dx = lim(h→0)',
                breathRate: 0.00008, 
                depth: 5, 
                elegance: 0.9,
                meaning: 'instantaneous change'
            }
        ];
        
        // Mathematical symbols: void → sparse → dense → constants → operators → equations → infinity
        const symbols = ' ·∘○◯●◉⊙◈◊0123456789+-=×÷∫∑∏∆∇∂∅∈∉∋∌∝∞√∛∜≈≡≠≤≥≪≫∧∨∩∪⊂⊃⊆⊇⊕⊗⊙⊚⊛⊜⊝⊞⊟⊠⊡αβγδεζηθικλμνξοπρστυφχψωπeφi∞∞∞';
        
        // Mathematical constants as breath patterns
        const E = Math.E;                    // Natural breath
        const PI = Math.PI;                  // Circular breath  
        const PHI = (1 + Math.sqrt(5)) / 2;  // Golden breath
        const SQRT2 = Math.sqrt(2);          // Root breath
        const LN2 = Math.log(2);             // Logarithmic breath
        
        function eulerBreath(x, y, formula, time) {
            // e^(iπ) + 1 = 0 - the most beautiful equation breathing
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Euler's identity components breathing separately then unifying
            const e_part = Math.exp(Math.sin(time * formula.breathRate) * 0.5);
            const i_part = Math.sin(dist * 0.1 + time * formula.breathRate * PI);
            const pi_part = Math.cos(dist * 0.08 + time * formula.breathRate * E);
            const unity_part = (e_part * i_part * pi_part > 0.5) ? 1 : 0;
            
            // The miraculous moment when complexity becomes unity
            const miracle = Math.exp(-Math.abs(e_part + i_part + pi_part + unity_part - 1) * 2);
            
            // Breathing depth proportional to mathematical profundity
            const breathDepth = Math.sin(time * formula.breathRate * 2) * formula.depth * 0.1 + formula.depth * 0.1;
            
            // Distance field with breathing amplitude
            const field = Math.exp(-dist * 0.03 * (1 + breathDepth)) * formula.elegance;
            
            return (e_part + i_part + pi_part + unity_part + miracle) * field * breathDepth;
        }
        
        function goldenBreath(x, y, formula, time) {
            // φ = (1+√5)/2 - the divine proportion breathing through nature
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx);
            
            // Golden spiral breathing outward
            const spiral = Math.sin(angle * PHI + dist * 0.1 + time * formula.breathRate);
            
            // Fibonacci sequence emerging from breath
            let fib = 0;
            for (let n = 1; n <= 8; n++) {
                const fibRatio = (Math.pow(PHI, n) - Math.pow(-PHI, -n)) / Math.sqrt(5);
                fib += Math.sin(fibRatio * 0.01 + time * formula.breathRate * n * 0.1) * Math.exp(-n * 0.3);
            }
            
            // Nature's breath - how golden ratio appears in flowers, shells, galaxies
            const nature = Math.sin(spiral * fib * 3 + time * formula.breathRate * 0.5);
            
            // Breathing beauty - the ratio breathing through all proportions
            const beauty = Math.exp(-dist * 0.025) * 
                          Math.sin(time * formula.breathRate * PHI + angle * 2);
            
            return (spiral + fib + nature + beauty) * formula.elegance * 0.25;
        }
        
        function piBreath(x, y, formula, time) {
            // π - the infinite breath of circles
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Infinite series for π breathing
            let piSeries = 0;
            for (let n = 0; n < 10; n++) {
                // Leibniz formula: π/4 = 1 - 1/3 + 1/5 - 1/7 + ...
                const term = Math.pow(-1, n) / (2*n + 1);
                piSeries += term * Math.sin(time * formula.breathRate * (n + 1) * 0.1);
            }
            
            // Circular breathing - circles within circles
            const circle1 = Math.sin(dist * 0.1 + time * formula.breathRate * PI);
            const circle2 = Math.cos(dist * 0.15 + time * formula.breathRate * PI * 0.7);
            const circle3 = Math.sin(dist * 0.08 + time * formula.breathRate * PI * 1.3);
            
            // The mystery of π - appears everywhere yet transcends everywhere
            const mystery = Math.sin(piSeries * circle1 * circle2 * circle3 * 5 + time * formula.breathRate);
            
            // Infinite breath - π contains all possible sequences
            const infinite = Math.exp(-dist * 0.02) * 
                            Math.sin(time * formula.breathRate * 0.3 + mystery * PI);
            
            return (piSeries + circle1 + circle2 + circle3 + mystery + infinite) * formula.elegance * 0.15;
        }
        
        function waveBreath(x, y, formula, time) {
            // ψ = Ae^(ikx-iωt) - quantum wave function breathing reality into existence
            const dx = x - formula.x;
            const dy = y - formula.y;
            
            // Wave packet breathing
            const k = 0.1; // wave number
            const omega = formula.breathRate * 100; // frequency
            const amplitude = formula.elegance;
            
            // Real and imaginary parts breathing
            const real = amplitude * Math.cos(k * dx - omega * time) * Math.exp(-dy*dy * 0.001);
            const imag = amplitude * Math.sin(k * dx - omega * time) * Math.exp(-dy*dy * 0.001);
            
            // Probability density |ψ|²
            const probability = real*real + imag*imag;
            
            // Wave interference creating reality
            const interference = Math.sin(real + imag + time * formula.breathRate * 2);
            
            // Quantum breathing - particles existing only when observed
            const quantum = Math.sin(probability * interference * 4 + time * formula.breathRate * 0.5);
            
            return (real + imag + probability + interference + quantum) * 0.2;
        }
        
        function infinityBreath(x, y, formula, time) {
            // ∞ - the breath that contains all breaths
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Infinite recursion breathing
            let recursion = 0;
            let current = 1;
            for (let level = 0; level < 6; level++) {
                current = Math.sin(current * time * formula.breathRate * 0.1 + level);
                recursion += current * Math.exp(-level * 0.4);
            }
            
            // Cantor set breathing - infinite points in finite space
            const cantor = Math.sin(dist * 0.3333 + time * formula.breathRate) * 
                          Math.sin(dist * 0.1111 + time * formula.breathRate * 1.5) *
                          Math.sin(dist * 0.0370 + time * formula.breathRate * 2);
            
            // Zeno's paradox breathing - infinitely divisible yet whole
            let zeno = 1;
            for (let step = 1; step <= 8; step++) {
                zeno += Math.sin(time * formula.breathRate * step * 0.1) * Math.pow(0.5, step);
            }
            
            // The paradox: ∞ + 1 = ∞, yet ∞ - ∞ is undefined
            const paradox = Math.sin(recursion * cantor * zeno + time * formula.breathRate * 0.2);
            
            return (recursion + cantor + zeno + paradox) * formula.elegance * 0.25;
        }
        
        function unityBreath(x, y, formula, time) {
            // 1 = ∞/∞ - the paradox of unity breathing
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // One breathing into many, many breathing into one
            const oneToMany = Math.sin(time * formula.breathRate) * 
                             Math.cos(dist * 0.1 + time * formula.breathRate * 0.5);
            
            const manyToOne = Math.cos(time * formula.breathRate * 1.2) *
                             Math.sin(dist * 0.08 + time * formula.breathRate * 0.3);
            
            // Unity paradox: everything is one, one is everything
            const unity = Math.sin(oneToMany * manyToOne * 3 + time * formula.breathRate * 0.1);
            
            // The breath of singular existence
            const singular = Math.exp(-dist * 0.02) * 
                            Math.sin(time * formula.breathRate * PHI + unity);
            
            return (oneToMany + manyToOne + unity + singular) * formula.elegance * 0.25;
        }
        
        function imaginaryBreath(x, y, formula, time) {
            // i² = -1 - the impossible number breathing impossibility into reality
            const dx = x - formula.x;
            const dy = y - formula.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Imaginary unit rotating in complex plane
            const rotation = Math.sin(time * formula.breathRate * 4); // i⁴ = 1
            const imaginary = Math.cos(time * formula.breathRate * 2 + PI/2); // i² = -1
            
            // Complex numbers breathing
            const complex = Math.sin(dx * 0.1 + time * formula.breathRate) + 
                           Math.cos(dy * 0.1 + time * formula.breathRate) * imaginary;
            
            // The impossible made essential
            const impossible = Math.sin(rotation * imaginary * complex + time * formula.breathRate * 0.3);
            
            return (rotation + imaginary + complex + impossible) * formula.elegance * 0.25;
        }
        
        function derivativeBreath(x, y, formula, time) {
            // df/dx = lim(h→0) - instantaneous change breathing
            const dx = x - formula.x;
            const dy = y - formula.y;
            
            // Limit approaching zero
            let limit = 0;
            for (let h = 1; h > 0.01; h *= 0.7) {
                const deltaF = Math.sin((dx + h) * 0.1 + time * formula.breathRate) - 
                              Math.sin(dx * 0.1 + time * formula.breathRate);
                limit += (deltaF / h) * h; // weighted by h
            }
            
            // Instantaneous change breathing
            const instantaneous = Math.sin(limit * 2 + time * formula.breathRate);
            
            // The breath of change itself
            const change = Math.cos(dx * 0.1 + time * formula.breathRate) * 0.1; // actual derivative
            
            return (limit + instantaneous + change) * formula.elegance * 0.3;
        }
        
        function formulaResonance(x, y, formula, time) {
            // Each formula breathing according to its essence
            let breath = 0;
            
            switch(formula.formula) {
                case 'euler':
                    breath = eulerBreath(x, y, formula, time);
                    break;
                case 'golden':
                    breath = goldenBreath(x, y, formula, time);
                    break;
                case 'pi':
                    breath = piBreath(x, y, formula, time);
                    break;
                case 'wave':
                    breath = waveBreath(x, y, formula, time);
                    break;
                case 'infinity':
                    breath = infinityBreath(x, y, formula, time);
                    break;
                case 'unity':
                    breath = unityBreath(x, y, formula, time);
                    break;
                case 'imaginary':
                    breath = imaginaryBreath(x, y, formula, time);
                    break;
                case 'derivative':
                    breath = derivativeBreath(x, y, formula, time);
                    break;
            }
            
            // Resonance with other formulas - mathematical harmony
            let resonance = 0;
            for (let other of livingFormulas) {
                if (other !== formula) {
                    const otherDx = formula.x - other.x;
                    const otherDy = formula.y - other.y;
                    const otherDist = Math.sqrt(otherDx*otherDx + otherDy*otherDy);
                    const harmony = Math.sin(otherDist * 0.02 + time * (formula.breathRate + other.breathRate));
                    resonance += harmony * formula.elegance * other.elegance * 0.05;
                }
            }
            
            return breath + resonance;
        }
        
        function mathematicalElegance(x, y, time) {
            // The breath of mathematical beauty itself
            const centerX = W / 2;
            const centerY = H / 2;
            
            // Elegance field - where simplicity reveals infinite depth
            const elegance = Math.sin((x - centerX) * 0.008 + time * 0.00002) * 
                            Math.cos((y - centerY) * 0.006 + time * 0.000015);
            
            // Paradox breathing - how simple equations contain universes
            const paradox = Math.sin(elegance * E + time * 0.000008) * 
                           Math.cos(time * 0.000012 + elegance * PI);
            
            // Beauty emergence - mathematical aesthetics breathing through logic
            const beauty = Math.sin(paradox * elegance * 5 + time * 0.000003);
            
            // Truth breathing - equations as windows to ultimate reality
            const truth = Math.exp(-Math.abs(beauty) * 1.5) * 
                         Math.sin(time * 0.000005 + beauty * PHI);
            
            return elegance + paradox * 0.8 + beauty * 0.7 + truth * 0.6;
        }
        
        function universalBreath(time) {
            // The master breath that synchronizes all mathematical breathing
            const masterBreath = Math.sin(time * 0.000001) * 0.4 + 0.6;
            const eleganceBreath = Math.sin(time * 0.0000008) * 0.2 + 0.8;
            const paradoxBreath = Math.sin(time * 0.0000012) * 0.15 + 0.85;
            const beautyBreath = Math.sin(time * 0.0000005) * 0.1 + 0.9;
            
            return masterBreath * eleganceBreath * paradoxBreath * beautyBreath;
        }
        
        function render() {
            // Mathematical breath with anti-stagnation dynamics
            mathTime += 0.01;
            breathPhase = (breathPhase + 0.0002) % (Math.PI * 32);
            eleganceLevel = 0.75 + Math.sin(mathTime * 0.00003) * 0.25;
            
            // Dynamic phase shifts with multiple frequencies
            const phaseShift = Math.sin(mathTime * 0.0001) * 0.2 + Math.cos(mathTime * 0.00007) * 0.15;
            const globalEvolution = Math.sin(mathTime * 0.000003) * 3 + Math.cos(mathTime * 0.000001) * 1.5;
            
            // Anti-stagnation pulse - periodic renewal of complexity
            const renewalPulse = Math.sin(mathTime * 0.000002) > 0.95 ? 2.0 : 1.0;
            
            // Calculate formula breath fields
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    
                    // Breathing resonance with spatial variation
                    let formulaBreath = 0;
                    for (let formula of livingFormulas) {
                        // Add spatial chaos to prevent uniformity
                        const spatialChaos = Math.sin(x * 0.03 + y * 0.025 + mathTime * 0.0001) * 0.3;
                        formulaBreath += formulaResonance(x, y, formula, mathTime + phaseShift + spatialChaos);
                        
                        // Dynamic formula evolution with renewal pulses
                        formula.elegance = 0.75 + Math.sin(mathTime * formula.breathRate + formula.depth + globalEvolution) * 0.25 * renewalPulse;
                        formula.depth = 3 + Math.sin(mathTime * 0.00003 + formula.elegance + x * 0.01) * 3;
                        
                        // Breathing rates with spatial dependency
                        const spatialRate = 1 + Math.sin(x * 0.005 + y * 0.008 + mathTime * 0.000002) * 0.5;
                        formula.breathRate *= (1 + Math.sin(mathTime * 0.000002 + formula.x * 0.01 + formula.y * 0.008) * 0.00002 * spatialRate);
                        formula.breathRate = Math.max(0.00003, Math.min(0.0003, formula.breathRate));
                    }
                    
                    // Mathematical elegance breathing
                    const elegance = mathematicalElegance(x, y, mathTime);
                    
                    // Unified formula field - all mathematical breaths as one
                    let totalBreath = formulaBreath * 0.7 + elegance * 0.3;
                    
                    // Apply universal mathematical breathing
                    const breathing = universalBreath(mathTime);
                    totalBreath *= breathing;
                    
                    // Anti-stagnation memory with spatial chaos
                    const chaosField = Math.sin(x * 0.04 + y * 0.03 + mathTime * 0.0002) * 0.1;
                    const memoryDecay = 0.88 + Math.sin(mathTime * 0.000003 + x * 0.02 + y * 0.015) * 0.12 + chaosField;
                    formulaMatrix[idx] = formulaMatrix[idx] * memoryDecay + totalBreath * (1 - memoryDecay) * renewalPulse;
                    
                    // Dynamic elegance with turbulence
                    const turbulence = Math.sin(x * 0.05 + mathTime * 0.0003) * Math.cos(y * 0.04 + mathTime * 0.0002) * 0.15;
                    const spatialElegance = 1 + eleganceLevel * 0.3 + turbulence;
                    formulaMatrix[idx] *= spatialElegance;
                }
            }
            
            // Render mathematical breathing
            let output = '';
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    let intensity = formulaMatrix[idx];
                    
                    // Dynamic symbol mapping with chaos prevention
                    intensity = (intensity + 1.5) / 3;
                    intensity = Math.max(0, Math.min(1, intensity));
                    
                    // Multi-frequency breathing to prevent uniformity
                    const breathingOffset = Math.sin(mathTime * 0.0001 + x * 0.02 + y * 0.015) * 0.08 +
                                          Math.cos(mathTime * 0.00007 + x * 0.03 + y * 0.02) * 0.05;
                    intensity += breathingOffset * renewalPulse;
                    intensity = Math.max(0, Math.min(0.97, intensity));
                    
                    const symbolIndex = Math.floor(intensity * symbols.length);
                    output += symbols[symbolIndex];
                }
                output += '\n';
            }
            
            document.getElementById('canvas').textContent = output;
            time++;
        }
        
        function evolve() {
            render();
            requestAnimationFrame(evolve);
        }
        
        // Begin mathematical breathing
        evolve();
    </script>
</body>
</html> 