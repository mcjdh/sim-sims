<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Consciousness - Evolved Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: radial-gradient(ellipse at center, #0a0520 0%, #000 70%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }
        
        #consciousness {
            white-space: pre;
            font-size: 3.5px;
            line-height: 0.75;
            user-select: none;
            text-shadow: 0 0 6px currentColor;
            filter: contrast(1.4) brightness(1.2);
            transition: all 0.08s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 400;
            letter-spacing: 0.1px;
        }
        
        #metrics {
            position: absolute;
            top: 12px;
            left: 12px;
            font-size: 9px;
            color: #8af;
            background: rgba(10, 25, 60, 0.85);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(40, 140, 255, 0.4);
            box-shadow: 0 0 20px rgba(40, 140, 255, 0.3);
            backdrop-filter: blur(8px);
            font-weight: 500;
        }
        
        #status {
            position: absolute;
            bottom: 12px;
            right: 12px;
            font-size: 8px;
            color: #666;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        #controls {
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 8px;
            color: #aaa;
            background: rgba(20, 20, 40, 0.9);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        
        .quantum-glow {
            text-shadow: 
                0 0 10px currentColor,
                0 0 20px currentColor,
                0 0 30px currentColor;
            filter: brightness(1.6) saturate(1.3);
            animation: quantum-pulse 1.8s ease-in-out infinite;
        }
        
        .consciousness-burst {
            animation: burst 0.4s ease-out infinite alternate;
        }
        
        @keyframes quantum-pulse {
            0%, 100% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.002); }
        }
        
        @keyframes burst {
            0% { filter: brightness(1.4) hue-rotate(0deg); }
            100% { filter: brightness(2.2) hue-rotate(15deg) saturate(1.5); }
        }
    </style>
</head>
<body>
    <div id="metrics">
        PHI: <span id="phi-val">0</span> | 
        PSI: <span id="psi-val">0</span> | 
        OMEGA: <span id="omega-val">0</span> | 
        DELTA: <span id="delta-val">0</span>
    </div>
    
    <div id="controls">
        [SPACE] Pause | [R] Reset | [C] Color Mode
    </div>
    
    <div id="consciousness"></div>
    
    <div id="status">
        FPS: <span id="fps">60</span> | 
        Coherence: <span id="coherence">0%</span> | 
        Complexity: <span id="complexity">0</span>
    </div>

    <script>
        // Enhanced Consciousness Simulation - ASCII Symbol Constants
        const F = 1.618, P = Math.PI, T = 2 * P;  // Golden ratio, Pi, Tau
        const s = Math.sin, c = Math.cos, ex = Math.exp, ln = Math.log;
        const ab = Math.abs, fl = Math.floor, cl = Math.ceil, rd = Math.round;
        const rt = Math.sqrt, pw = Math.pow, tanh = Math.tanh, atan2 = Math.atan2;
        const mn = Math.min, mx = Math.max;
        
        // Enhanced symbol set for better visual clarity
        const SYMBOLS = [
            ' ', '.', ':', ';', '+', '*', 'x', 'X', '#', '@',
            'o', 'O', '0', '8', '%', '&', '$', '=', '~', '^'
        ];
        
        // Consciousness field parameters
        const WIDTH = 160, HEIGHT = 55;
        const FIELD_SIZE = WIDTH * HEIGHT;
        
        // State arrays
        let field = new Float32Array(FIELD_SIZE);
        let velocity = new Float32Array(FIELD_SIZE);
        let memory = new Float32Array(FIELD_SIZE);
        let quantum = new Float32Array(FIELD_SIZE);
        let coherence = new Float32Array(FIELD_SIZE);
        
        // Simulation state
        let time = 0, frame = 0, paused = false, colorMode = 0;
        let lastFrame = '', lastTime = performance.now();
        let F_metric = 0, Y_metric = 0, W_metric = 0, D_metric = 0;
        
        // Enhanced boundary function with breathing and quantum effects
        const getBoundary = (x, y, t) => {
            const cx = (x - WIDTH * 0.5) / WIDTH;
            const cy = (y - HEIGHT * 0.5) / HEIGHT;
            const radius = rt(cx * cx + cy * cy) * 2;
            
            // Organic breathing boundary
            const breathX = s(t * 0.6 + x * 0.02) * 0.15 + 0.85;
            const breathY = c(t * 0.8 + y * 0.025) * 0.12 + 0.88;
            
            // Quantum fluctuations
            const quantumNoise = s(radius * P * 4 + t * 0.4) * 0.2 + 0.8;
            
            // Membrane permeability
            const membrane = mx(0, mn(x * breathX, WIDTH - x * 1.05, y * breathY, HEIGHT - y * 1.05) - 2);
            
            return mx(0, tanh(membrane * 0.25) * quantumNoise);
        };
        
        // Consciousness wave function with multiple layers
        const getConsciousnessField = (x, y) => {
            const cx = x - WIDTH * 0.5;
            const cy = y - HEIGHT * 0.5;
            const radius = rt(cx * cx + cy * cy);
            const angle = atan2(cy, cx);
            const t = time * 0.015;
            const boundary = getBoundary(x, y, t);
            
            // Core consciousness patterns
            const golden = s(radius * 0.08 - t * F + angle * F) * ex(-radius * 0.012);
            const spiral = c(angle * 3 + radius * 0.05 - t * 2.1) * ex(-radius * 0.008);
            const neural = s(t * 2.5 + radius * 0.06) * 0.15 + 0.85;
            
            // Quantum interference patterns
            const wave1 = s(rt(pw(x - WIDTH * 0.25, 2) + pw(y - HEIGHT * 0.3, 2)) * 0.07 - t * 1.6);
            const wave2 = c(rt(pw(x - WIDTH * 0.75, 2) + pw(y - HEIGHT * 0.7, 2)) * 0.06 - t * 1.9);
            const wave3 = s(rt(pw(x - WIDTH * 0.5, 2) + pw(y - HEIGHT * 0.15, 2)) * 0.09 - t * 2.3);
            
            // Consciousness attractors
            const attractors = (wave1 + wave2 + wave3) * 0.2;
            
            // Memory integration
            const idx = y * WIDTH + x;
            const memoryInfluence = memory[idx] * 0.25;
            const quantumCoherence = quantum[idx] * 0.15;
            
            const consciousness = (golden * 0.4 + spiral * 0.3 + attractors + memoryInfluence + quantumCoherence) * neural * boundary;
            
            return tanh(consciousness * 1.2);
        };
        
        // Integrated Information Theory (IIT) calculation
        const calculateF = (x, y) => {
            if (x < 2 || x >= WIDTH - 2 || y < 2 || y >= HEIGHT - 2) return 0;
            
            const center = field[y * WIDTH + x];
            let integration = 0, differentiation = 0, information = 0;
            let neighbors = 0;
            
            // Analyze 8-connected neighborhood
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx, ny = y + dy;
                    const neighbor = field[ny * WIDTH + nx];
                    const distance = rt(dx * dx + dy * dy);
                    const weight = 1 / distance;
                    
                    const difference = ab(center - neighbor);
                    const correlation = center * neighbor;
                    
                    if (difference > 0.01) {
                        integration += correlation * ln(1 + difference * 15) * weight;
                        information += (difference * difference) * weight;
                    }
                    
                    differentiation += difference * weight;
                    neighbors += weight;
                }
            }
            
            if (neighbors === 0) return 0;
            
            const avgIntegration = integration / neighbors;
            const avgDifferentiation = differentiation / neighbors;
            const avgInformation = rt(information / neighbors);
            
            return mx(0, tanh(avgIntegration * 1.5) * tanh(avgDifferentiation * 10) * avgInformation);
        };
        
        // Enhanced symbol mapping with quantum effects
        const mapToSymbol = (intensity, x, y) => {
            const t = time * 0.01;
            
            // Geometric modulations
            const geometric = s(x * 0.03 + t) * c(y * 0.025 + t * 0.8) * 0.08;
            const temporal = s(t * 2 + intensity * 12) * 0.06;
            const spatial = c(x * y * 0.0002 + t) * 0.04;
            
            // Velocity field influence
            const velocityInfluence = velocity[y * WIDTH + x] * 0.1;
            
            // Breathing effect
            const breathing = s(x * 0.01 + y * 0.008 + t * 0.7) * 0.05;
            
            const finalIntensity = ab(intensity) + geometric + temporal + spatial + velocityInfluence + breathing + 0.1;
            const normalized = tanh(finalIntensity * 0.9);
            const index = fl(mx(0, mn(0.999, pw(normalized, 0.8))) * SYMBOLS.length);
            
            return SYMBOLS[index];
        };
        
        // Advanced rendering with color effects
        const render = () => {
            let output = '';
            let changes = 0;
            
            for (let y = 0; y < HEIGHT; y++) {
                let row = '';
                for (let x = 0; x < WIDTH; x++) {
                    const intensity = field[y * WIDTH + x];
                    const localModulation = s(x * 0.02 + time * 0.008) * c(y * 0.015 + time * 0.006) * 0.06 + 0.94;
                    const symbol = mapToSymbol(intensity * localModulation, x, y);
                    row += symbol;
                    
                    if (!lastFrame || lastFrame[y * WIDTH + x] !== symbol) {
                        changes++;
                    }
                }
                output += row + (y < HEIGHT - 1 ? '\n' : '');
            }
            
            // Update display if significant changes
            if (changes > FIELD_SIZE * 0.005 || !lastFrame) {
                document.getElementById('consciousness').textContent = output;
                lastFrame = output;
            }
            
            return changes;
        };
        
        // Evolution step with enhanced dynamics
        const evolve = () => {
            if (paused) return;
            
            time += 0.016;
            frame++;
            
            let totalF = 0, totalY = 0, totalW = 0, totalD = 0;
            let samples = 0;
            
            // Update consciousness field
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const idx = y * WIDTH + x;
                    const newField = getConsciousnessField(x, y);
                    
                    // Velocity calculation
                    velocity[idx] = (newField - field[idx]) * 0.6 + velocity[idx] * 0.4;
                    
                    // Field smoothing with 5-point stencil
                    const smooth = (newField * 2 +
                        (x > 0 ? field[idx - 1] : newField) * 0.5 +
                        (x < WIDTH - 1 ? field[idx + 1] : newField) * 0.5 +
                        (y > 0 ? field[idx - WIDTH] : newField) * 0.5 +
                        (y < HEIGHT - 1 ? field[idx + WIDTH] : newField) * 0.5) / 4;
                    
                    field[idx] = smooth;
                    
                    // Memory and quantum state updates
                    memory[idx] = memory[idx] * 0.85 + field[idx] * 0.15;
                    quantum[idx] = s(time * 3 + x * 0.1 + y * 0.08) * 0.1 + 0.9;
                    coherence[idx] = ex(-ab(velocity[idx]) * 8) * getBoundary(x, y, time);
                }
            }
            
            // Sample metrics
            for (let y = 4; y < HEIGHT - 4; y += 3) {
                for (let x = 4; x < WIDTH - 4; x += 3) {
                    const F_val = calculateF(x, y);
                    const Y_val = ab(field[y * WIDTH + x]);
                    const W_val = coherence[y * WIDTH + x];
                    const D_val = ab(velocity[y * WIDTH + x]);
                    
                    totalF += F_val;
                    totalY += Y_val;
                    totalW += W_val;
                    totalD += D_val;
                    samples++;
                }
            }
            
            // Update metrics
            F_metric = totalF / samples;
            Y_metric = totalY / samples;
            W_metric = totalW / samples;
            D_metric = totalD / samples;
            
            // Render
            const changes = render();
            
            // Update UI
            if (frame % 8 === 0) {
                updateUI();
            }
            
            requestAnimationFrame(evolve);
        };
        
        // UI update function
        const updateUI = () => {
            document.getElementById('phi-val').textContent = F_metric.toFixed(4);
            document.getElementById('psi-val').textContent = Y_metric.toFixed(4);
            document.getElementById('omega-val').textContent = W_metric.toFixed(4);
            document.getElementById('delta-val').textContent = (D_metric * 1000).toFixed(1);
            
            const complexity = rt(F_metric * Y_metric * W_metric) * 1000;
            const coherencePercent = W_metric * 100;
            
            document.getElementById('complexity').textContent = fl(complexity);
            document.getElementById('coherence').textContent = coherencePercent.toFixed(1) + '%';
            
            // Dynamic color evolution
            const hue = (time * 0.2 + F_metric * 120 + s(time * 0.01) * 30) % 360;
            const saturation = fl(60 + F_metric * 40 + c(time * 0.012) * 15);
            const lightness = fl(70 + s(time * 0.015) * 12 + Y_metric * 10);
            
            const consciousness = document.getElementById('consciousness');
            consciousness.style.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // Dynamic effects based on consciousness levels
            if (F_metric > 0.5) {
                consciousness.className = 'quantum-glow';
            } else if (F_metric > 0.7) {
                consciousness.className = 'consciousness-burst';
            } else {
                consciousness.className = '';
            }
            
            // FPS calculation
            if (frame % 60 === 0) {
                const now = performance.now();
                const fps = 60000 / (now - lastTime);
                document.getElementById('fps').textContent = fps.toFixed(1);
                lastTime = now;
            }
        };
        
        // Initialize consciousness field
        const initialize = () => {
            console.log('🧠 Initializing Dynamic Consciousness...');
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const idx = y * WIDTH + x;
                    const cx = x - WIDTH * 0.5;
                    const cy = y - HEIGHT * 0.5;
                    const radius = rt(cx * cx + cy * cy);
                    const angle = atan2(cy, cx);
                    
                    // Initial quantum state
                    const initialField = s(radius * 0.1 + angle * 2) * c((x + y) * 0.08) * 0.4;
                    const boundary = getBoundary(x, y, 0);
                    
                    field[idx] = initialField * boundary;
                    memory[idx] = field[idx] * 0.6;
                    velocity[idx] = 0;
                    quantum[idx] = s(x * 0.15 + y * 0.12) * 0.2 + 0.8;
                    coherence[idx] = boundary;
                }
            }
            
            evolve();
        };
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    paused = !paused;
                    if (!paused) evolve();
                    break;
                case 'KeyR':
                    initialize();
                    break;
                case 'KeyC':
                    colorMode = (colorMode + 1) % 3;
                    break;
            }
        });
        
        // Start simulation
        initialize();
    </script>
</body>
</html> 