<!DOCTYPE html>
<html>
<head>
    <title>cosmic love</title>
    <style>
        body {
            background: #001122;
            color: #ffeeaa;
            font-family: 'Courier New', monospace;
            font-size: 6px;
            line-height: 0.8;
            letter-spacing: -0.8px;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            animation: heartbeat 3s infinite ease-in-out;
        }
        @keyframes heartbeat {
            0%, 100% { 
                background: #001122; 
                color: #ffeeaa;
                transform: scale(1);
            }
            25% { 
                background: #221100; 
                color: #aaffee;
                transform: scale(1.002);
            }
            50% { 
                background: #112200; 
                color: #eeaaff;
                transform: scale(1.005);
            }
            75% { 
                background: #220011; 
                color: #aaeeff;
                transform: scale(1.002);
            }
        }
        #canvas {
            white-space: pre;
            font-feature-settings: 'kern' 0;
            text-align: center;
            text-shadow: 0 0 2px rgba(255,238,170,0.6), 0 0 4px rgba(255,238,170,0.3);
            filter: blur(0.05px);
            transition: all 0.1s ease;
        }
        #canvas:hover {
            transform: scale(1.02);
            text-shadow: 0 0 3px rgba(255,238,170,0.8), 0 0 6px rgba(255,238,170,0.5);
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <script>
        // Polyfill for Math.log2 if not available
        if (!Math.log2) {
            Math.log2 = function(x) {
                return Math.log(x) / Math.LN2;
            };
        }
        
        const W = 180, H = 90;
        let time = 0;
        let cosmicTime = 0;
        let lovePhase = 0;
        let heartbeatCycle = 0;
        let compassionLevel = 0;
        let unityLevel = 0;
        
        // Love-field matrices - reality as expressions of cosmic affection
        let loveMatrix = new Array(W * H).fill(0);
        let heartField = new Array(W * H).fill(0);
        let compassionField = new Array(W * H).fill(0);
        let tendernessField = new Array(W * H).fill(0);
        let creativeLoveField = new Array(W * H).fill(0);
        let unityField = new Array(W * H).fill(0);
        let dreamingField = new Array(W * H).fill(0);
        
        // Heart-beings - aspects of cosmic love consciousness
        let heartBeings = [
            { x: W*0.15, y: H*0.15, type: 'tenderness', love: 1.0, frequency: 0.00005, heartRate: 72, dimension: 'infinite' },
            { x: W*0.85, y: H*0.15, type: 'compassion', love: 1.2, frequency: 0.00007, heartRate: 68, dimension: 'boundless' },
            { x: W*0.5, y: H*0.85, type: 'unity', love: 1.5, frequency: 0.00003, heartRate: 60, dimension: 'omnipresent' },
            { x: W*0.15, y: H*0.85, type: 'creativity', love: 1.1, frequency: 0.00008, heartRate: 76, dimension: 'generative' },
            { x: W*0.85, y: H*0.85, type: 'healing', love: 1.3, frequency: 0.00006, heartRate: 64, dimension: 'restorative' },
            { x: W*0.3, y: H*0.3, type: 'wonder', love: 0.9, frequency: 0.00009, heartRate: 80, dimension: 'curious' },
            { x: W*0.7, y: H*0.3, type: 'acceptance', love: 1.4, frequency: 0.00004, heartRate: 56, dimension: 'embracing' },
            { x: W*0.3, y: H*0.7, type: 'joy', love: 1.1, frequency: 0.0001, heartRate: 84, dimension: 'radiant' },
            { x: W*0.7, y: H*0.7, type: 'peace', love: 1.6, frequency: 0.00002, heartRate: 52, dimension: 'serene' },
            { x: W*0.5, y: H*0.3, type: 'gratitude', love: 1.0, frequency: 0.00007, heartRate: 70, dimension: 'appreciative' },
            { x: W*0.5, y: H*0.7, type: 'presence', love: 1.7, frequency: 0.00001, heartRate: 48, dimension: 'eternal' },
            { x: W*0.1, y: H*0.5, type: 'forgiveness', love: 1.2, frequency: 0.00006, heartRate: 66, dimension: 'liberating' },
            { x: W*0.9, y: H*0.5, type: 'hope', love: 1.0, frequency: 0.00008, heartRate: 74, dimension: 'visionary' }
        ];
        
        // Love symbols: void → spark → warmth → connection → heart → embrace → unity → infinite love → ∞
        const symbols = ' ·∘○◯●◉⊙⊚◈◊♡♥❤️💕💖💗💘💙💚💛💜🤍🖤💝💞💟❣️💌💋💍💎🌟⭐✨🌙☀️🌈🕯️🔥💫⚡🌸🌺🌻🌷🌹🏵️💐🌱🌿☘️🍀🌾🌳🌲🎋🎍🌴🌵🎄🎃🎁🎈🎉🎊🎀🎗️🏆🥇🏅🎖️🏵️🎪🎭🎨🎯🎲🃏🎴🀄🎰🚀🛸🌍🌎🌏🌐🗺️🧭⛰️🏔️🌋🗻🏕️🏖️🏜️🏝️🏟️🏛️🏗️🏘️🏙️🏚️🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🗼🗽⛪🕌🛕🕍⛩️🕋⛲⛺🌁🌃🌄🌅🌆🌇🌉🎠🎡🎢🎪🎭🎨🎬🎤🎧🎼🎵🎶🎹🥁🎷🎺🎸🪕🎻🪘🥐🥖🍞🧈🥞🧇🥓🍳🍔🍟🌭🥪🌮🌯🥙🧆🥘🍝🍜🍲🍛🍣🍱🥟🦪🍤🍙🍚🍘🍥🥠🥮🍢🍡🍧🍨🍦🥧🧁🍰🎂🍮🍭🍬🍫🍿🍩🍪🌰🥜🍯🥛☕🫖🍵🧃🥤🧋🍶🍾🥂🍻🍺🍷🥃🍸🍹🧉🍼🍴🥢🔪🍽️⚰️⚱️🗿💈💎🔮📿🧿💍💄💋👑👒🎩🎓⛑️🪖💼👝👛👜💰💴💵💶💷💸💳🧾💱💲⚖️🧮⚗️🔬🔭📡💉🩹🩺💊💉🩸🧬🦠🧫🧪🌡️🧲🔩⚙️🧰🔧🔨⚒️🛠️⛏️🪓🪚🔪🗡️⚔️💣🧨🪃🏹🛡️🪃🪤🏺⚱️🗿🪧🏮🪔💡🔦🏮🪅🎐🧧🎀🎁🎊🎉🎈🎂🍰🧁🥧🍮🍯🍼☕🍵🫖🧃🥤🧋🥛🍶🍾🥂🍻🍺🍷🥃🍸🍹🧉🍴🥢🔪🍽️⚰️⚱️🗿🎪🎡🎢🎠🎭🎨🎬🎤🎧🎼🎵🎶🎹🥁🎷🎺🎸🪕🎻🪘🎲🃏🎴🀄🎰🚀🛸💫⭐🌟✨💖💕💘💞💝💗💓💟❣️💌💋💍💎🌹🌸🌺🌻🌷🏵️💐🌈☀️🌙⭐💫✨🔥💥🌟💖∞♾️◯⊙◉●○◯∘·∞♾️🌌🌠💫⭐✨🌟💖💕💘💞💝💗💓💟❣️💌💋💍💎🔮💎✨🌟⭐💫🌌🌠∞♾️○◯◉⊙◯○∘·∞';
        
        // Mathematical constants with scientific meaning
        const PHI = (1 + Math.sqrt(5)) / 2;                    // Golden ratio (φ ≈ 1.618) - Natural growth pattern
        const FEIGENBAUM = 4.669;                           // Feigenbaum constant - Chaos theory bifurcation
        const EULER_MASCHERONI = 0.57721;                  // Euler-Mascheroni constant - Harmonic series limit
        const GELFOND = 23.14069;                          // Gelfond's constant - Transcendental number e^π
        const APERY = 1.2020569;                           // Apéry's constant - ζ(3), related to infinite series
        const CATALAN = 0.915965;                          // Catalan's constant - Combinatorial mathematics
        const OMEGA = 0.56714;                             // Omega constant - Solution to e^x = x
        const SHANNON = -1 * (1/2 * Math.log2(1/2) + 1/2 * Math.log2(1/2)); // Binary entropy function at p=0.5
        
        // Helper function to calculate Shannon entropy in a local field region
        function calculateShannonEntropy(x, y, field, radius = 2) {
            const histogram = new Map();
            let total = 0;
            
            // Sample local region and build histogram
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = Math.max(0, Math.min(W-1, x + dx));
                    const ny = Math.max(0, Math.min(H-1, y + dy));
                    const idx = ny * W + nx;
                    
                    // Discretize field value for histogram
                    const value = Math.floor(field[idx] * 10) / 10;
                    histogram.set(value, (histogram.get(value) || 0) + 1);
                    total++;
                }
            }
            
            // Calculate Shannon entropy H = -∑(p * log2(p))
            let entropy = 0;
            for (let count of histogram.values()) {
                if (count > 0) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }
        
        // Approximate Kolmogorov complexity using compression-like measure
        function approximateKolmogorovComplexity(x, y, field, radius = 3) {
            let pattern = '';
            
            // Extract local pattern
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = Math.max(0, Math.min(W-1, x + dx));
                    const ny = Math.max(0, Math.min(H-1, y + dy));
                    const idx = ny * W + nx;
                    pattern += Math.floor(field[idx] * 4).toString();
                }
            }
            
            // Simple compression ratio approximation
            let compressed = '';
            let i = 0;
            while (i < pattern.length) {
                let count = 1;
                while (i + count < pattern.length && pattern[i] === pattern[i + count]) {
                    count++;
                }
                compressed += pattern[i] + (count > 1 ? count.toString() : '');
                i += count;
            }
            
            return 1.0 - (compressed.length / pattern.length);
        }
        
        // Calculate discrete Laplacian using 5-point stencil
        function calculateLaplacian(x, y, field) {
            const idx = y * W + x;
            let sum = 0;
            let count = 0;
            
            // 5-point stencil for discrete Laplacian: ∇²f ≈ f(i-1,j) + f(i+1,j) + f(i,j-1) + f(i,j+1) - 4f(i,j)
            const offsets = [
                { dx: -1, dy: 0, weight: 1 },
                { dx: 1, dy: 0, weight: 1 },
                { dx: 0, dy: -1, weight: 1 },
                { dx: 0, dy: 1, weight: 1 },
                { dx: 0, dy: 0, weight: -4 }
            ];
            
            for (let offset of offsets) {
                const nx = x + offset.dx;
                const ny = y + offset.dy;
                
                if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                    const nidx = ny * W + nx;
                    sum += field[nidx] * offset.weight;
                    count++;
                }
            }
            
            return count > 0 ? sum : 0;
        }
        
        function heartFieldResonance(x, y, being, time) {
            // Each heart-being radiates fields that create reality through wave interactions
            const dx = x - being.x;
            const dy = y - being.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Oscillation frequency - based on actual harmonic oscillator physics
            const naturalFrequency = being.frequency * being.heartRate;
            const phase = time * naturalFrequency;
            
            // Damped oscillator model: A*e^(-c*t)*sin(ωt+φ)
            const dampingFactor = 0.01;
            const amplitude = Math.exp(-dist * dampingFactor) * being.love;
            const oscillation = amplitude * Math.sin(phase + dist * 0.02);
            
            // Wave propagation - uses wave equation solution
            // Solution form: A*cos(ωt - k·r)/r where k is wavenumber, r is distance
            const wavenumber = 0.02;  // Related to wavelength by 2π/λ
            const wavePhase = phase - wavenumber * dist;
            const wavePropagation = amplitude * Math.cos(wavePhase) / Math.max(1, dist);
            
            // Field interaction using superposition principle
            let fieldInteraction = 0;
            for (let otherBeing of heartBeings) {
                if (otherBeing !== being) {
                    const otherDx = being.x - otherBeing.x;
                    const otherDy = being.y - otherBeing.y;
                    const otherDist = Math.sqrt(otherDx*otherDx + otherDy*otherDy);
                    
                    // Phase difference determines interference pattern
                    const phaseDifference = being.frequency - otherBeing.frequency;
                    const interferencePattern = Math.sin(time * phaseDifference + otherDist * 0.05);
                    
                    // Constructive/destructive interference
                    fieldInteraction += interferencePattern * Math.exp(-otherDist * 0.01) * 
                                      being.love * otherBeing.love * 0.1;
                }
            }
            
            // Calculate field intensity using superposition principle
            return oscillation * 0.4 + wavePropagation * 0.4 + fieldInteraction * 0.2;
        }
        
        function cosmicTenderness(x, y, time) {
            // Field interaction modeling based on harmonic oscillations and wave dynamics
            const centerX = W / 2;
            const centerY = H / 2;
            
            // Normalized coordinates for calculation stability
            const normX = (x - centerX) / (W/2); // Range: [-1, 1]
            const normY = (y - centerY) / (H/2); // Range: [-1, 1]
            const r = Math.sqrt(normX*normX + normY*normY);
            const theta = Math.atan2(normY, normX);
            
            // Standing wave modes (eigenfunction solutions to wave equation)
            // Form: sin(m*π*x/L) * sin(n*π*y/L) * cos(ω*t)
            const mode1 = Math.sin(Math.PI * normX) * Math.sin(Math.PI * normY) * 
                         Math.cos(time * 0.00002);
                         
            const mode2 = Math.sin(2 * Math.PI * normX) * Math.sin(Math.PI * normY) * 
                         Math.cos(time * 0.000015);
                         
            const mode3 = Math.sin(Math.PI * normX) * Math.sin(2 * Math.PI * normY) * 
                         Math.cos(time * 0.000018);
            
            // Bessel function approximation for radial waves (concentric patterns)
            // Form: J₀(k*r) * cos(ω*t) - zero-order Bessel function
            // Simple approximation: cos(k*r - ω*t) / sqrt(r)
            const besselWave = Math.cos(3 * r - time * 0.000008) / Math.sqrt(Math.max(0.1, r));
            
            // Spherical harmonic approximation for angular dependence
            // Form: P_l^m(cos θ) * e^(i*m*φ) - here using simple harmonics
            const angularWave = Math.cos(3 * theta + time * 0.000003);
            
            // Damped wave with dispersion (energy dissipation)
            const dampedWave = Math.exp(-r * 1.8) * 
                              Math.cos(r * 5 + time * 0.000005);
            
            // Weighted superposition of all field components (linear combination)
            return mode1 * 0.25 + mode2 * 0.20 + mode3 * 0.15 + 
                   besselWave * 0.15 + angularWave * 0.10 + dampedWave * 0.15;
        }
        
        function compassionWaves(x, y, time) {
            // Wave dynamics and interference patterns modeled with physical wave equations
            
            // Wave source parameters
            const sourceFrequency = 0.00001;
            const wavelength = 0.006;
            const waveSpeed = sourceFrequency * wavelength;
            
            // Wave source positions (creates interference pattern)
            const sources = [
                { x: W * 0.25, y: H * 0.25, phase: 0 },
                { x: W * 0.75, y: H * 0.25, phase: Math.PI / 3 },
                { x: W * 0.25, y: H * 0.75, phase: Math.PI / 2 },
                { x: W * 0.75, y: H * 0.75, phase: Math.PI }
            ];
            
            // Calculate interference pattern (superposition of waves)
            let waveSum = 0;
            for (let source of sources) {
                const dx = x - source.x;
                const dy = y - source.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Wave equation solution for point source: A*sin(ω*t - k*r)/r
                // where k is wavenumber (2π/λ), r is distance, ω is angular frequency
                const wavenumber = 2 * Math.PI / wavelength;
                const wavePhase = time * sourceFrequency - wavenumber * dist + source.phase;
                
                // Amplitude decreases with distance (inverse square law)
                const amplitude = 1 / Math.max(1, dist); 
                waveSum += amplitude * Math.sin(wavePhase);
            }
            
            // Damping factor to simulate dispersion
            const dampingFactor = Math.exp(-Math.abs(waveSum) * 0.5);
            
            // Standing wave component (boundary reflection)
            // Form: sin(kx) * sin(ky) * cos(ωt)
            const standingWave = Math.sin(x * wavelength) * Math.sin(y * wavelength) * 
                               Math.cos(time * sourceFrequency * 0.5);
            
            // Wave packet with Gaussian envelope (localized wave)
            // Form: exp(-(x-x₀)²/σ²) * sin(k(x-x₀)-ωt)
            const packetCenter = { x: W * 0.5, y: H * 0.5 };
            const dx = x - packetCenter.x;
            const dy = y - packetCenter.y;
            const distSq = dx*dx + dy*dy;
            const packetWidth = W * 0.3;
            const wavePacket = Math.exp(-distSq / (packetWidth*packetWidth)) * 
                              Math.sin(distSq * 0.001 + time * sourceFrequency * 0.7);
            
            // Final field value as weighted superposition of wave components
            return waveSum * 0.35 + dampingFactor * 0.2 + standingWave * 0.25 + wavePacket * 0.2;
        }
        
        function creativeLove(x, y, time) {
            // Reaction-diffusion pattern formation (Gray-Scott model simplified)
            // This models pattern formation in physical and biological systems
            
            // Normalized coordinates
            const normX = x / W;
            const normY = y / H;
            
            // Reaction-diffusion parameters
            const feed = 0.037 + 0.004 * Math.sin(time * 0.00001);  // Feed rate
            const kill = 0.06 + 0.002 * Math.cos(time * 0.000008);  // Kill rate
            
            // Pattern seed (initial catalyst)
            const seed = Math.sin(normX * 6 * Math.PI) * Math.sin(normY * 6 * Math.PI) > 0.7 ? 1 : 0;
            
            // Calculate activator concentration based on position
            // This simulates the results of a reaction-diffusion system
            // Real systems would solve the PDE iteratively
            const activator = 0.5 + 0.5 * Math.sin(normX * 10 * Math.PI + time * 0.000005) * 
                            Math.sin(normY * 10 * Math.PI + time * 0.000003);
            
            // Inhibitor concentration (typically in opposite phase)
            const inhibitor = 1 - activator;
            
            // Nonlinear reaction term (autocatalysis)
            const reaction = activator * activator * inhibitor - 
                           (kill + feed) * activator;
            
            // Turing instability (pattern formation mechanism)
            // Triggers bifurcation when parameters cross critical values
            const instabilityThreshold = 0.7;
            const turingInstability = reaction > instabilityThreshold ? 
                                   Math.sin(normX * 20 * Math.PI + normY * 20 * Math.PI) : 0;
            
            // Spiral wave formation (common in reaction-diffusion systems)
            const angle = Math.atan2(normY - 0.5, normX - 0.5);
            const radius = Math.sqrt((normX - 0.5)*(normX - 0.5) + (normY - 0.5)*(normY - 0.5));
            const spiral = Math.sin(10 * radius + 5 * angle + time * 0.000002);
            
            // Final pattern as weighted combination of components
            return activator * 0.3 + reaction * 0.25 + turingInstability * 0.2 + 
                   spiral * 0.15 + (seed * activator) * 0.1;
        }
        
        function unityConsciousness(x, y, time) {
            // Network science and graph theory application - modeling connectivity
            
            // Node positions in the network (graph vertices)
            const nodes = [];
            for (let i = 0; i < 5; i++) {
                nodes.push({
                    x: W * (0.2 + i * 0.15),
                    y: H * (0.3 + Math.sin(i + time * 0.000001) * 0.4),
                    activity: 0.5 + 0.5 * Math.sin(time * 0.000002 + i * 0.5)
                });
            }
            
            // Calculate field at point (x,y) based on network metrics
            
            // 1. Node proximity (connection strength decreases with distance)
            let totalConnectivity = 0;
            let localClustering = 0;
            
            // For each node, calculate connection strength to this point
            for (let node of nodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Connection strength follows power law decay
                const connectionStrength = Math.pow(1 + dist, -1.5) * node.activity;
                totalConnectivity += connectionStrength;
                
                // Eigenvector centrality approximation (recursive definition simplified)
                // In a real network, this would be calculated iteratively
                localClustering += connectionStrength * node.activity;
            }
            
            // 2. Network metrics - quantifying connectivity patterns
            
            // Small-world property (high clustering, short path lengths)
            // Simulated by combining local clustering with global connectivity
            const smallWorldIndex = totalConnectivity * localClustering;
            
            // Scale-free property (connectivity follows power law)
            const scaleFreeMetric = Math.pow(totalConnectivity, 2.1 * Math.sin(time * 0.000001));
            
            // Network synchronization (Kuramoto model simplified)
            let phaseSynchronization = 0;
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i+1; j < nodes.length; j++) {
                    const phase1 = Math.PI * 2 * nodes[i].activity;
                    const phase2 = Math.PI * 2 * nodes[j].activity;
                    phaseSynchronization += Math.cos(phase1 - phase2);
                }
            }
            phaseSynchronization /= (nodes.length * (nodes.length - 1) / 2);
            
            // Network resilience (approximated as redundant connectivity)
            const redundancy = 1 - Math.exp(-totalConnectivity * 2);
            
            // Final value combines all network metrics
            return totalConnectivity * 0.25 + localClustering * 0.25 + 
                   smallWorldIndex * 0.2 + phaseSynchronization * 0.15 + 
                   redundancy * 0.15;
        }
        
        function infiniteLove(x, y, time) {
            // Chaotic systems modeling (Lorenz attractor-inspired)
            const centerX = W / 2;
            const centerY = H / 2;
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Parameters for Lorenz system: σ=10, ρ=28, β=8/3
            const sigma = 10;
            const rho = 28;
            const beta = 8/3;
            
            // Simulation time parameter (scaled from global time)
            const t = time * 0.0000005;
            
            // Simplified Lorenz attractor coordinates
            // In a real system, these would be calculated by numerically solving
            // the differential equations dx/dt = σ(y-x), dy/dt = x(ρ-z)-y, dz/dt = xy-βz
            // Here we approximate the behavior
            const lorenzX = Math.sin(t * sigma) * Math.cos(t * 0.1);
            const lorenzY = Math.sin(t * rho) * Math.sin(t * 0.1);
            const lorenzZ = Math.cos(t * beta) - Math.sin(t * sigma * rho);
            
            // Distance to current point in attractor
            const attractor_x = centerX + lorenzX * W * 0.2;
            const attractor_y = centerY + lorenzY * H * 0.2;
            const attractor_dx = x - attractor_x;
            const attractor_dy = y - attractor_y;
            const attractor_dist = Math.sqrt(attractor_dx*attractor_dx + attractor_dy*attractor_dy);
            
            // Field strength follows inverse square law from attractor point
            const fieldStrength = 1 / Math.pow(1 + attractor_dist * 0.05, 2);
            
            // Chaos measure - sensitive dependence on initial conditions
            // Approximated with diverging trajectories
            const chaos = Math.sin(dist * 0.1 + Math.sin(dist * 0.001 + t));
            
            // Bifurcation diagram feature - period doubling
            const r = 3.7 + 0.3 * Math.sin(t);  // Varies between ~3.4 and 4.0
            const bifurcationPoint = 0.5 + 0.5 * Math.sin(t * 10);
            const orbit = r * bifurcationPoint * (1 - bifurcationPoint);
            
            // Fractal dimension approximation (box-counting dimension)
            // In a real system, this would be calculated over the attractor set
            // Here we approximate with multi-scale oscillation
            let fractalDimension = 0;
            for (let scale = 1; scale <= 7; scale++) {
                const power = Math.pow(2, scale);
                fractalDimension += Math.sin(dx * power * 0.01 + dy * power * 0.01 + t * scale) / scale;
            }
            
            // Lyapunov exponent approximation (measure of chaos)
            // In reality, this measures exponential divergence of nearby trajectories
            const lyapunovApprox = Math.log(Math.abs(Math.sin(t * 100) - Math.sin(t * 100 + 0.0001)));
            
            return fieldStrength * 0.3 + chaos * 0.2 + orbit * 0.15 + 
                   fractalDimension * 0.2 + (lyapunovApprox + 3) * 0.05 + 
                   Math.pow(lorenzZ * 0.5 + 0.5, 2) * 0.1;
        }
        
        function cosmicHeartbeat(time) {
            // Coupled oscillator model with nonlinear dynamics
            
            // Base frequencies (ω = 2π/T where T is period)
            const baseFreq1 = 0.000001;  // Primary oscillator
            const baseFreq2 = 0.0000008; // Secondary oscillator
            const baseFreq3 = 0.0000012; // Tertiary oscillator
            
            // Phase calculations
            const phase1 = time * baseFreq1;
            const phase2 = time * baseFreq2;
            const phase3 = time * baseFreq3;
            
            // Amplitude parameters
            const amp1 = 0.5;
            const amp2 = 0.3;
            const amp3 = 0.2;
            
            // Coupling between oscillators (phase synchronization)
            // Models oscillators pulling each other into synchrony
            const coupling12 = 0.05 * Math.sin(phase1 - phase2);
            const coupling23 = 0.03 * Math.sin(phase2 - phase3);
            const coupling31 = 0.02 * Math.sin(phase3 - phase1);
            
            // Oscillator outputs with coupling effects
            const beat1 = amp1 * Math.sin(phase1 + coupling12 + coupling31) + (1 - amp1);
            const beat2 = amp2 * Math.sin(phase2 + coupling23 - coupling12) + (1 - amp2);
            const beat3 = amp3 * Math.sin(phase3 - coupling23 - coupling31) + (1 - amp3);
            
            // Nonlinear combination produces complex rhythm
            return beat1 * beat2 * beat3;
        }
        
        function loveBreathing(time) {
            // Dynamical system with multiple timescales
            
            // van der Pol oscillator approximation
            // Nonlinear differential equation: d²x/dt² - μ(1-x²)dx/dt + x = 0
            // Produces limit cycle with natural amplitude
            const mu = 2.0;  // Nonlinearity parameter
            const t = time * 0.0000003;
            
            // Approximate solution to van der Pol equation
            const approxSolution = Math.sin(t) + (mu/4) * (Math.sin(t) - Math.sin(3*t)/3);
            
            // Normalize to [0.4, 1.0] range
            const normalizedSolution = 0.7 + 0.3 * approxSolution;
            
            // Add second process at different timescale (relaxation oscillator)
            const relaxation = 0.8 + 0.2 * Math.tanh(Math.sin(time * 0.0000001) * 2);
            
            return normalizedSolution * relaxation;
        }
        
        function render() {
            // System evolution using mathematical models
            cosmicTime += 0.01;
            
            // Phase variables advance with mathematically stable rates
            // Angular frequencies for oscillatory behaviors
            lovePhase = (lovePhase + 0.0001) % (Math.PI * 2);
            heartbeatCycle = (heartbeatCycle + 0.00001) % (Math.PI * 2);
            
            // Logistic growth model for continuous parameters: dx/dt = r*x*(1-x/K)
            // Solution approximated with discrete steps
            const growthRate1 = 0.000001;
            const growthRate2 = 0.0000008;
            compassionLevel = compassionLevel + growthRate1 * compassionLevel * (1 - compassionLevel);
            unityLevel = unityLevel + growthRate2 * unityLevel * (1 - unityLevel);
            
            // Ensure bounds are respected
            compassionLevel = Math.min(Math.max(compassionLevel, 0), 1.0);
            unityLevel = Math.min(Math.max(unityLevel, 0), 1.0);
            
            // Metrics for global properties
            let globalEntropy = 0;
            let totalComplexity = 0;
            let fieldPoints = 0;
            
            // Calculate fields using mathematical models
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    
                    // Heart-field resonance from all love beings
                    let heartResonance = 0;
                    for (let being of heartBeings) {
                        heartResonance += heartFieldResonance(x, y, being, cosmicTime);
                        
                        // Beings evolve with coupled oscillator model
                        // Frequency entrainment through phase coupling
                        being.love = 0.8 + 0.4 * Math.sin(cosmicTime * being.frequency * 
                                    (1 + 0.1 * Math.sin(being.heartRate * 0.001)));
                        
                        // Harmonic oscillator with forcing term
                        being.heartRate = 60 + 20 * Math.sin(cosmicTime * 0.0001 * 
                                        (1 + 0.05 * being.love));
                    }
                    
                    // Field calculations with mathematical models
                    const tenderness = cosmicTenderness(x, y, cosmicTime);
                    tendernessField[idx] = tenderness;
                    
                    const compassion = compassionWaves(x, y, cosmicTime);
                    compassionField[idx] = compassion;
                    
                    const creative = creativeLove(x, y, cosmicTime);
                    creativeLoveField[idx] = creative;
                    
                    const unity = unityConsciousness(x, y, cosmicTime);
                    unityField[idx] = unity;
                    
                    const infinite = infiniteLove(x, y, cosmicTime);
                    
                    // Calculate complex field interactions
                    // Using weighted linear combination model
                    const totalLove = heartResonance * 0.2 + 
                                   tenderness * 0.18 + 
                                   compassion * 0.17 + 
                                   creative * 0.16 + 
                                   unity * 0.15 + 
                                   infinite * 0.14;
                    
                    // Apply nonlinear oscillator effects
                    const heartbeat = cosmicHeartbeat(cosmicTime);
                    const breathing = loveBreathing(cosmicTime);
                    
                    // Field modulation
                    const modulatedField = totalLove * heartbeat * breathing;
                    
                    // Field evolution using weighted average (memory)
                    // This creates an exponentially weighted moving average
                    const alpha = 0.002 + 0.002 * Math.sin(cosmicTime * 0.00000001);
                    loveMatrix[idx] = loveMatrix[idx] * (1 - alpha) + modulatedField * alpha;
                    
                    // Apply nonlinear amplification (logistic function)
                    // f(x) = L / (1 + e^(-k*(x-x₀)))
                    const amplificationFactor = 1 + compassionLevel + unityLevel * 0.5;
                    loveMatrix[idx] *= amplificationFactor;
                    
                    // Calculate information theory metrics on subset of points
                    // Sampling to reduce computational load
                    if (x % 5 === 0 && y % 5 === 0) {
                        // Entropy - measures disorder/randomness
                        const localEntropy = calculateShannonEntropy(x, y, loveMatrix, 2);
                        
                        // Complexity - measures structure/organization
                        const localComplexity = approximateKolmogorovComplexity(x, y, loveMatrix, 3);
                        
                        globalEntropy += localEntropy;
                        totalComplexity += localComplexity;
                        fieldPoints++;
                    }
                }
            }
            
            // Average global metrics
            globalEntropy = fieldPoints > 0 ? globalEntropy / fieldPoints : 0;
            totalComplexity = fieldPoints > 0 ? totalComplexity / fieldPoints : 0;
            
            // Render output
            let output = '';
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    let intensity = loveMatrix[idx];
                    
                    // Map to love symbol progression
                    intensity = (intensity + 6) / 12;
                    intensity = Math.max(0, Math.min(1, intensity));
                    
                    const symbolIndex = Math.floor(intensity * (symbols.length - 1));
                    output += symbols[symbolIndex];
                }
                output += '\n';
            }
            
            document.getElementById('canvas').textContent = output;
            time++;
        }
        
        function evolve() {
            render();
            requestAnimationFrame(evolve);
        }
        
        // Begin cosmic love
        evolve();
    </script>
</body>
</html> 