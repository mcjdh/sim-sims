---
description: 
globs: 
alwaysApply: false
---
# Mathematical Techniques for Living Simulations

## 🧮 Core Mathematical Patterns That Create Life

### Wave Interference Mathematics

**Multiple Source Interference** (Perfect example: [waves.html](mdc:gen1/waves.html)):
```javascript
function wave(x, y, centerX, centerY, freq, phase) {
    const dist = Math.sqrt((x-centerX)*(x-centerX) + (y-centerY)*(y-centerY));
    return Math.sin(dist * freq + phase);
}

// Three moving sources create organic interference
const w1 = Math.sin(d1 * 0.5 - t * 0.1);  // Center source
const w2 = Math.sin(d2 * 0.4 - t * 0.08); // Moving source 1
const w3 = Math.sin(d3 * 0.3 - t * 0.12); // Moving source 2
const combined = w1 + w2 * 0.7 + w3 * 0.5;
```

### Fractal and Complex Dynamics

**Mandelbrot-Style Evolution** (From [flow.html](mdc:gen1/flow.html)):
```javascript
function fractalPoint(x, y, time) {
    const zx = (x - W/2) / (W/4);
    const zy = (y - H/2) / (H/4);
    
    // Evolving complex parameters
    const cx = 0.7269 * Math.cos(time * 0.001) - 0.1;
    const cy = 0.1889 * Math.sin(time * 0.0013) + 0.2;
    
    let x0 = zx, y0 = zy;
    let iteration = 0;
    
    while (x0*x0 + y0*y0 <= 4 && iteration < 16) {
        const xtemp = x0*x0 - y0*y0 + cx;
        y0 = 2*x0*y0 + cy;
        x0 = xtemp;
        iteration++;
    }
    
    return iteration / 16;
}
```

### Golden Ratio Spirals

**Natural Spiral Mathematics** (φ = 1.618...):
```javascript
const φ = (1 + Math.sqrt(5)) / 2;

function spiralField(x, y, time) {
    const r = Math.sqrt(x*x + y*y);
    const θ = Math.atan2(y - H/2, x - W/2);
    return Math.sin(θ * φ + r * 0.1 + time);
}
```

### Quantum and Probability Mathematics

**Wave Function Evolution** (From [probability-gardens.html](mdc:gen5/probability-gardens.html)):
```javascript
function waveFunction(x, y, time) {
    // Schrödinger equation evolution
    const ψ_real = Math.sin(x * 0.1 + time * 0.005) * Math.cos(y * 0.08 - time * 0.007);
    const ψ_imag = Math.cos(x * 0.12 - time * 0.006) * Math.sin(y * 0.09 + time * 0.004);
    
    // Probability density |ψ|²
    return ψ_real * ψ_real + ψ_imag * ψ_imag;
}
```

**Uncertainty Principle**:
```javascript
function quantumFluctuation(x, y, time) {
    const momentum = Math.sin(x * 0.15 + time * 0.01);
    const position = Math.cos(y * 0.12 - time * 0.008);
    
    // Uncertainty relation ΔxΔp ≥ ℏ/2
    const uncertainty = Math.abs(momentum * position) * 0.5;
    const vacuum = (Math.random() - 0.5) * 0.1 * Math.exp(-time * 0.0001);
    
    return uncertainty + vacuum;
}
```

### Neural and Cognitive Patterns

**Multi-Layer Neural Activation** (From [attention.html](mdc:gen1/attention.html)):
```javascript
function neuralActivation(x, y, time, layer) {
    const layerOffset = layer * 0.1;
    const activation = Math.tanh(
        Math.sin(x * 0.15 + time * 0.01 + layerOffset) + 
        Math.cos(y * 0.12 + time * 0.008 + layerOffset) +
        Math.sin((x + y) * 0.08 + time * 0.015 + layerOffset)
    );
    
    return 1 / (1 + Math.exp(-activation * 3)); // Sigmoid
}
```

**Attention Mechanism**:
```javascript
function attentionMechanism(x, y, head, time) {
    const dx = x - head.x;
    const dy = y - head.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    head.focus = Math.sin(time * 0.005 + head.x * 0.01) * 20 + 25;
    
    return Math.exp(-dist * dist / (head.focus * head.focus)) * 
           Math.sin(time * 0.03 + dist * 0.1);
}
```

### Flow and Field Mathematics

**Vector Fields and Fluid Dynamics**:
```javascript
function flowField(x, y, time) {
    // Multiple overlapping flow patterns
    const t1 = time * 0.004;
    const t2 = time * 0.007;
    
    // Fibonacci spiral flow
    const r = Math.sqrt(x*x + y*y);
    const θ = Math.atan2(y - H/2, x - W/2);
    const spiral = Math.sin(θ * φ + r * 0.1 + t1);
    
    // Double helix flow
    const helix = Math.sin(θ * 2 + r * 0.15 + t2) * Math.cos(θ * 3 - r * 0.08 + t1);
    
    return (spiral + helix) / 2;
}
```

### Temporal and Crystal Mathematics

**Crystal Symmetry** (From [temporal-crystals.html](mdc:gen5/temporal-crystals.html)):
```javascript
function temporalCrystal(x, y, seed, time) {
    const dx = x - seed.x;
    const dy = y - seed.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    // Crystalline symmetry patterns
    const symmetryWave = Math.cos(angle * seed.symmetry + time * seed.frequency);
    const radialOrder = Math.cos(dist * 0.4 + time * 0.01);
    const orderParameter = Math.exp(-dist * 0.08);
    
    return symmetryWave * radialOrder * orderParameter;
}
```

### Memory and Persistence Patterns

**Organic Memory Decay** (Universal pattern across all simulations):
```javascript
// Different decay rates for different phenomena
field[idx] = field[idx] * 0.85 + newValue * 0.15;     // Fast decay
memory[idx] = memory[idx] * 0.92 + intensity * 0.08;  // Slow decay
attention[idx] = attention[idx] * 0.87 + focus * 0.13; // Medium decay

// Breathing decay rates
const decayRate = 0.89 + Math.sin(time * 0.001) * 0.04;
field[idx] = field[idx] * decayRate + newValue * (1 - decayRate);
```

### Chaos and Randomness Integration

**Controlled Chaos**:
```javascript
// Small random elements for organic feel
const chaos = (Math.random() - 0.5) * 0.1 * Math.exp(-time * 0.0001);
const systematicChaos = Math.sin(x * 0.3 + time * 0.02) * Math.random() * 0.2;

// Sudden emergence events
if (Math.random() < 0.001) {
    intensity += Math.random() * 2; // Rare emergence spikes
}
```

## 🎯 Combination Strategies

**Layer Interference** (The key to complexity):
```javascript
// Combine multiple mathematical systems
const base = fractalPoint(x, y, time) * 0.4;
const flow = flowField(x, y, time) * 0.3;
const quantum = waveFunction(x, y, time) * 0.3;
const chaos = (Math.random() - 0.5) * 0.1;

let intensity = base + flow + quantum + chaos;
intensity *= breathingModulation(time);
```

Each technique should create **interference patterns** that generate emergent complexity from simple mathematical rules.

