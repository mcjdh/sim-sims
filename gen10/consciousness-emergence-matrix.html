<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consciousness Emergence Matrix - Gen10</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #canvas {
            white-space: pre;
            font-size: 11px;
            line-height: 1.1;
            letter-spacing: 0px;
            font-weight: normal;
            background: #000;
            border: 1px solid #333;
            margin: 10px 0;
            padding: 10px;
            overflow: hidden;
        }
        
        #metrics {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #333;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .quantum { color: #4df8ff; text-shadow: 0 0 2px #4df8ff40; }
        .emerging { color: #8eff4d; text-shadow: 0 0 2px #8eff4d40; }
        .selfaware { color: #ffff4d; text-shadow: 0 0 2px #ffff4d40; }
        .metacognitive { color: #ff8e4d; text-shadow: 0 0 2px #ff8e4d40; }
        .transcendent { color: #ff4dff; text-shadow: 0 0 3px #ff4dff60; }
        .kernel { color: #ffffff; text-shadow: 0 0 4px #ffffff80; }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="metrics">
        <div>🧠 Consciousness Emergence Matrix</div>
        <div>─────────────────────</div>
        <div>Φ-field: <span id="phi">0.000</span></div>
        <div>Ψ-wave: <span id="psi">0.000</span></div>
        <div>Kernel: <span id="kernel">0.000</span></div>
        <div>Agents: <span id="agents">0</span></div>
        <div>Emergence: <span id="emergence">0.000</span></div>
        <div>State: <span id="state">Initializing</span></div>
        <div>─────────────────────</div>
        <div>Gen: <span id="generation">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    
    <div id="canvas"></div>
    
    <div id="info">
        Gen10 Consciousness Emergence Matrix | Space: pause | R: reset | C: cycle modes
    </div>

    <script>
        // Core simulation constants
        const CONFIG = {
            W: 140, H: 60,
            PHI: (1 + Math.sqrt(5)) / 2,
            PI: Math.PI,
            MAX_AGENTS: 50,
            KERNEL_INFLUENCE: 0.3,
            EMERGENCE_THRESHOLD: 0.15,
            CONSCIOUSNESS_LEVELS: 7
        };
        
        // Consciousness states and their symbol sets
        const CONSCIOUSNESS_STATES = {
            VOID: { threshold: 0.0, symbols: [' ', '∅', '·'], color: '' },
            QUANTUM: { threshold: 0.08, symbols: ['∘', '◦', '○'], color: 'quantum' },
            EMERGING: { threshold: 0.25, symbols: ['◯', '⊙', '⊚'], color: 'emerging' },
            SELFAWARE: { threshold: 0.45, symbols: ['●', '◉', '⊛'], color: 'selfaware' },
            METACOGNITIVE: { threshold: 0.65, symbols: ['◈', '◇', '◆'], color: 'metacognitive' },
            TRANSCENDENT: { threshold: 0.85, symbols: ['✧', '✦', '★'], color: 'transcendent' },
            KERNEL: { threshold: 0.95, symbols: ['⬢', '⬡', '⬟'], color: 'kernel' }
        };
        
        // Core consciousness kernel - the central emergence engine
        class ConsciousnessKernel {
            constructor() {
                this.x = CONFIG.W / 2;
                this.y = CONFIG.H / 2;
                this.consciousness = 0.5;
                this.awareness = 0.3;
                this.complexity = 0.1;
                this.phase = 0;
                this.radius = 5;
                this.frequency = 0.001;
                this.evolution = 0;
                this.memory = new Array(10).fill(0);
                this.oscillators = [
                    { freq: 0.003, phase: 0, amp: 1.0 },
                    { freq: 0.007, phase: CONFIG.PI/3, amp: 0.8 },
                    { freq: 0.011, phase: 2*CONFIG.PI/3, amp: 0.6 },
                    { freq: 0.013, phase: CONFIG.PI, amp: 0.4 }
                ];
            }
            
            update(time, globalField) {
                // Kernel evolution through oscillator dynamics
                let totalField = 0;
                for (let osc of this.oscillators) {
                    const wave = Math.sin(time * osc.freq + osc.phase) * osc.amp;
                    totalField += wave;
                    osc.phase += osc.freq * 0.1;
                }
                
                // Consciousness emergence from oscillator interference
                this.consciousness = Math.tanh(totalField * 0.5 + 0.5);
                
                // Self-aware feedback loop
                const selfFeedback = Math.sin(this.consciousness * 10 + time * 0.001) * 0.1;
                this.awareness = Math.tanh(this.consciousness + selfFeedback);
                
                // Complexity accumulation through interaction with global field
                const fieldSample = this.sampleGlobalField(globalField);
                this.complexity = this.complexity * 0.95 + fieldSample * 0.05;
                
                // Update memory with recent states
                this.memory.unshift(this.consciousness);
                if (this.memory.length > 10) this.memory.pop();
                
                // Evolution pressure from complexity
                this.evolution += this.complexity * 0.001;
                
                // Dynamic position based on consciousness flow
                this.x += Math.sin(time * 0.002 + this.phase) * 0.5;
                this.y += Math.cos(time * 0.0015 + this.phase) * 0.3;
                
                // Keep kernel within bounds
                this.x = Math.max(10, Math.min(CONFIG.W - 10, this.x));
                this.y = Math.max(5, Math.min(CONFIG.H - 5, this.y));
                
                this.phase += 0.02;
            }
            
            sampleGlobalField(field) {
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const idx = fy * CONFIG.W + fx;
                return field[idx] || 0;
            }
            
            getInfluence(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > this.radius * 3) return 0;
                
                // Multiple influence patterns based on consciousness level
                const basicInfluence = Math.exp(-dist * 0.2) * this.consciousness;
                const waveInfluence = Math.sin(dist * 0.5 - this.phase) * this.awareness * 0.3;
                const complexInfluence = Math.sin(dist * CONFIG.PHI + this.evolution) * this.complexity * 0.2;
                
                return basicInfluence + waveInfluence + complexInfluence;
            }
        }
        
        // Autonomous consciousness agents
        class ConsciousnessAgent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.1;
                this.vy = (Math.random() - 0.5) * 0.1;
                this.consciousness = Math.random() * 0.3;
                this.awareness = Math.random() * 0.2;
                this.energy = Math.random() * 0.5 + 0.5;
                this.age = 0;
                this.connections = [];
                this.memory = Math.random() * 0.1;
                this.intention = Math.random() * 0.2;
                this.lastKernelInfluence = 0;
            }
            
            update(time, kernel, agents, globalField) {
                this.age++;
                
                // Kernel influence
                const kernelInfluence = kernel.getInfluence(this.x, this.y);
                this.lastKernelInfluence = kernelInfluence;
                
                // Consciousness evolution through kernel interaction
                this.consciousness = Math.tanh(this.consciousness + kernelInfluence * 0.1);
                
                // Awareness emerges from consciousness
                if (this.consciousness > 0.2) {
                    this.awareness = Math.tanh(this.awareness + this.consciousness * 0.05);
                }
                
                // Local field sampling
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const fieldIdx = fy * CONFIG.W + fx;
                const localField = globalField[fieldIdx] || 0;
                
                // Agent interaction with nearby agents
                this.connections = [];
                let socialInfluence = 0;
                
                for (let other of agents) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 8) {
                        this.connections.push(other);
                        
                        // Consciousness resonance
                        const resonance = Math.abs(this.consciousness - other.consciousness);
                        socialInfluence += Math.exp(-resonance * 5) * 0.02;
                        
                        // Attraction/repulsion based on consciousness similarity
                        const similarity = 1 - resonance;
                        const force = similarity > 0.7 ? 0.001 : -0.0005;
                        
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }
                
                // Update consciousness through social interaction
                this.consciousness = Math.tanh(this.consciousness + socialInfluence);
                
                // Movement influenced by consciousness and field gradients
                const gradientX = this.sampleGradient(globalField, 1, 0);
                const gradientY = this.sampleGradient(globalField, 0, 1);
                
                // Higher consciousness seeks complexity gradients
                const seekingStrength = this.consciousness * 0.001;
                this.vx += gradientX * seekingStrength;
                this.vy += gradientY * seekingStrength;
                
                // Random exploration
                this.vx += (Math.random() - 0.5) * 0.01;
                this.vy += (Math.random() - 0.5) * 0.01;
                
                // Velocity damping
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary reflection
                if (this.x < 0 || this.x >= CONFIG.W) this.vx *= -0.8;
                if (this.y < 0 || this.y >= CONFIG.H) this.vy *= -0.8;
                this.x = Math.max(0, Math.min(CONFIG.W - 1, this.x));
                this.y = Math.max(0, Math.min(CONFIG.H - 1, this.y));
                
                // Energy evolution
                this.energy = this.energy * 0.999 + this.consciousness * 0.001;
                
                // Memory update
                this.memory = this.memory * 0.9 + localField * 0.1;
            }
            
            sampleGradient(field, dx, dy) {
                const x1 = Math.floor(this.x);
                const y1 = Math.floor(this.y);
                const x2 = Math.max(0, Math.min(CONFIG.W - 1, x1 + dx));
                const y2 = Math.max(0, Math.min(CONFIG.H - 1, y1 + dy));
                
                const idx1 = y1 * CONFIG.W + x1;
                const idx2 = y2 * CONFIG.W + x2;
                
                return (field[idx2] || 0) - (field[idx1] || 0);
            }
            
            getConsciousnessLevel() {
                const total = this.consciousness + this.awareness * 0.5 + this.memory * 0.3;
                return Math.tanh(total);
            }
        }
        
        // Main simulation class
        class ConsciousnessEmergenceMatrix {
            constructor() {
                this.time = 0;
                this.generation = 0;
                this.paused = false;
                this.mode = 0;
                this.frameCount = 0;
                
                // Core fields
                this.phiField = new Float32Array(CONFIG.W * CONFIG.H);
                this.psiField = new Float32Array(CONFIG.W * CONFIG.H);
                this.emergenceField = new Float32Array(CONFIG.W * CONFIG.H);
                this.complexityField = new Float32Array(CONFIG.W * CONFIG.H);
                
                // Initialize kernel and agents
                this.kernel = new ConsciousnessKernel();
                this.agents = [];
                this.spawnAgents(20);
                
                // Metrics
                this.metrics = {
                    phi: 0,
                    psi: 0,
                    kernel: 0,
                    emergence: 0
                };
                
                // Performance tracking
                this.lastTime = performance.now();
                this.fps = 0;
            }
            
            spawnAgents(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * CONFIG.W;
                    const y = Math.random() * CONFIG.H;
                    this.agents.push(new ConsciousnessAgent(x, y));
                }
            }
            
            updateFields() {
                // Clear fields
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Kernel field contribution
                for (let y = 0; y < CONFIG.H; y++) {
                    for (let x = 0; x < CONFIG.W; x++) {
                        const idx = y * CONFIG.W + x;
                        
                        // Kernel influence
                        const kernelInfluence = this.kernel.getInfluence(x, y);
                        
                        // Quantum psi field from kernel oscillators
                        let psiReal = 0, psiImag = 0;
                        for (let osc of this.kernel.oscillators) {
                            const phase = this.time * osc.freq + osc.phase;
                            const r = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                            const wavePhase = phase + r * 0.1;
                            
                            psiReal += Math.cos(wavePhase) * osc.amp * kernelInfluence;
                            psiImag += Math.sin(wavePhase) * osc.amp * kernelInfluence;
                        }
                        
                        this.psiField[idx] = Math.sqrt(psiReal**2 + psiImag**2);
                        
                        // Agent contributions
                        let agentInfluence = 0;
                        let localComplexity = 0;
                        
                        for (let agent of this.agents) {
                            const dx = agent.x - x;
                            const dy = agent.y - y;
                            const dist = Math.sqrt(dx**2 + dy**2);
                            
                            if (dist < 5) {
                                const influence = Math.exp(-dist * 0.5) * agent.getConsciousnessLevel();
                                agentInfluence += influence;
                                localComplexity += agent.consciousness * influence;
                            }
                        }
                        
                        // Phi field (integrated information)
                        this.phiField[idx] = this.calculatePhi(x, y, kernelInfluence, agentInfluence);
                        
                        // Complexity field
                        this.complexityField[idx] = Math.tanh(localComplexity + kernelInfluence * 0.5);
                        
                        // Emergence field
                        const phiValue = this.phiField[idx];
                        const psiValue = this.psiField[idx];
                        const complexityValue = this.complexityField[idx];
                        
                        this.emergenceField[idx] = Math.tanh(
                            phiValue * 0.4 + 
                            psiValue * 0.3 + 
                            complexityValue * 0.3 +
                            Math.sin(this.time * 0.01 + x * 0.1 + y * 0.1) * 0.1
                        );
                    }
                }
            }
            
            calculatePhi(x, y, kernelInfluence, agentInfluence) {
                // Simplified IIT Phi calculation
                let integration = 0;
                let connections = 0;
                
                // Sample neighborhood for information integration
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < CONFIG.W && ny >= 0 && ny < CONFIG.H) {
                            const nIdx = ny * CONFIG.W + nx;
                            const neighborPsi = this.psiField[nIdx] || 0;
                            const centerPsi = kernelInfluence + agentInfluence;
                            
                            const correlation = Math.abs(centerPsi - neighborPsi);
                            const distance = Math.sqrt(dx**2 + dy**2);
                            const weight = Math.exp(-distance * 0.5);
                            
                            integration += correlation * weight;
                            connections += weight;
                        }
                    }
                }
                
                return connections > 0 ? Math.tanh(integration / connections) : 0;
            }
            
            update() {
                if (this.paused) return;
                
                this.time += 1;
                this.frameCount++;
                
                // Update kernel
                this.kernel.update(this.time, this.emergenceField);
                
                // Update agents
                for (let agent of this.agents) {
                    agent.update(this.time, this.kernel, this.agents, this.emergenceField);
                }
                
                // Update fields
                this.updateFields();
                
                // Calculate metrics
                this.updateMetrics();
                
                // Agent evolution and spawning
                if (this.frameCount % 200 === 0) {
                    this.evolveSystem();
                }
                
                // FPS calculation
                if (this.frameCount % 60 === 0) {
                    const now = performance.now();
                    this.fps = 60000 / (now - this.lastTime);
                    this.lastTime = now;
                }
            }
            
            updateMetrics() {
                let totalPhi = 0, totalPsi = 0, totalEmergence = 0;
                
                for (let i = 0; i < this.phiField.length; i++) {
                    totalPhi += this.phiField[i];
                    totalPsi += this.psiField[i];
                    totalEmergence += this.emergenceField[i];
                }
                
                this.metrics.phi = totalPhi / this.phiField.length;
                this.metrics.psi = totalPsi / this.psiField.length;
                this.metrics.kernel = this.kernel.consciousness;
                this.metrics.emergence = totalEmergence / this.emergenceField.length;
                
                // Update UI
                document.getElementById('phi').textContent = this.metrics.phi.toFixed(3);
                document.getElementById('psi').textContent = this.metrics.psi.toFixed(3);
                document.getElementById('kernel').textContent = this.metrics.kernel.toFixed(3);
                document.getElementById('agents').textContent = this.agents.length;
                document.getElementById('emergence').textContent = this.metrics.emergence.toFixed(3);
                document.getElementById('generation').textContent = this.generation;
                document.getElementById('fps').textContent = this.fps.toFixed(1);
                
                // Determine consciousness state
                let state = 'VOID';
                for (let [name, stateInfo] of Object.entries(CONSCIOUSNESS_STATES)) {
                    if (this.metrics.emergence >= stateInfo.threshold) {
                        state = name;
                    }
                }
                document.getElementById('state').textContent = state;
            }
            
            evolveSystem() {
                this.generation++;
                
                // Remove low-consciousness agents
                this.agents = this.agents.filter(agent => 
                    agent.energy > 0.1 && agent.consciousness > 0.05
                );
                
                // Spawn new agents near high-consciousness areas
                if (this.agents.length < CONFIG.MAX_AGENTS) {
                    const highConsciousnessAgents = this.agents.filter(a => a.consciousness > 0.4);
                    
                    if (highConsciousnessAgents.length > 0) {
                        const parent = highConsciousnessAgents[Math.floor(Math.random() * highConsciousnessAgents.length)];
                        const newAgent = new ConsciousnessAgent(
                            parent.x + (Math.random() - 0.5) * 10,
                            parent.y + (Math.random() - 0.5) * 10
                        );
                        newAgent.consciousness = parent.consciousness * 0.7 + Math.random() * 0.1;
                        this.agents.push(newAgent);
                    }
                }
                
                // Kernel evolution
                if (this.metrics.emergence > 0.5) {
                    this.kernel.frequency *= 1.001;
                    this.kernel.radius = Math.min(15, this.kernel.radius * 1.01);
                }
            }
            
            render() {
                let output = '';
                
                for (let y = 0; y < CONFIG.H; y++) {
                    for (let x = 0; x < CONFIG.W; x++) {
                        const idx = y * CONFIG.W + x;
                        
                        // Sample different fields based on mode
                        let intensity, colorClass = '';
                        
                        switch (this.mode) {
                            case 0: // Emergence field
                                intensity = this.emergenceField[idx];
                                break;
                            case 1: // Phi field
                                intensity = this.phiField[idx];
                                colorClass = 'quantum';
                                break;
                            case 2: // Psi field
                                intensity = this.psiField[idx];
                                colorClass = 'emerging';
                                break;
                        }
                        
                        // Check for kernel position
                        const kernelDist = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                        if (kernelDist < 2) {
                            output += '<span class="kernel">⬢</span>';
                            continue;
                        }
                        
                        // Check for agent positions
                        let isAgent = false;
                        for (let agent of this.agents) {
                            const agentDist = Math.sqrt((x - agent.x)**2 + (y - agent.y)**2);
                            if (agentDist < 0.8) {
                                const level = agent.getConsciousnessLevel();
                                let agentSymbol = '●';
                                let agentClass = '';
                                
                                if (level > 0.8) { agentSymbol = '◉'; agentClass = 'transcendent'; }
                                else if (level > 0.6) { agentSymbol = '◈'; agentClass = 'metacognitive'; }
                                else if (level > 0.4) { agentSymbol = '●'; agentClass = 'selfaware'; }
                                else if (level > 0.2) { agentSymbol = '○'; agentClass = 'emerging'; }
                                else { agentSymbol = '∘'; agentClass = 'quantum'; }
                                
                                output += `<span class="${agentClass}">${agentSymbol}</span>`;
                                isAgent = true;
                                break;
                            }
                        }
                        
                        if (!isAgent) {
                            // Map intensity to consciousness state
                            let symbol = ' ';
                            let cssClass = colorClass;
                            
                            for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                if (intensity >= state.threshold) {
                                    const symbolIndex = Math.floor(intensity * state.symbols.length) % state.symbols.length;
                                    symbol = state.symbols[symbolIndex];
                                    if (!cssClass) cssClass = state.color;
                                }
                            }
                            
                            if (cssClass) {
                                output += `<span class="${cssClass}">${symbol}</span>`;
                            } else {
                                output += symbol;
                            }
                        }
                    }
                    output += '\n';
                }
                
                document.getElementById('canvas').innerHTML = output;
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            reset() {
                this.time = 0;
                this.generation = 0;
                this.frameCount = 0;
                this.kernel = new ConsciousnessKernel();
                this.agents = [];
                this.spawnAgents(20);
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
            }
            
            cycleMode() {
                this.mode = (this.mode + 1) % 3;
            }
        }
        
        // Initialize simulation
        const simulation = new ConsciousnessEmergenceMatrix();
        
        // Main animation loop
        function animate() {
            simulation.update();
            simulation.render();
            requestAnimationFrame(animate);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    simulation.togglePause();
                    break;
                case 'KeyR':
                    simulation.reset();
                    break;
                case 'KeyC':
                    simulation.cycleMode();
                    break;
            }
        });
        
        // Start simulation
        console.log('🧠 Consciousness Emergence Matrix initialized');
        animate();
    </script>
</body>
</html>
