<!DOCTYPE html>
<!--
   Quantum Gateway Seed - Enhanced with True Quantum Mechanics:
   
   Features:
   - Complex wave functions (ψ = real + i*imaginary)
   - Quantum probability densities |ψ|²
   - Heisenberg uncertainty principle
   - Quantum vacuum fluctuations
   - Quantum tunneling probabilities  
   - Quantum entanglement correlations
   - Superposition states in keystone
   
   Symbols:
   ◉◎○ - Superposition states (keystone)
   ⚡ - High energy quantum states
   ✦✧ - Constructive/destructive interference
   ◆♦◇ - Various probability densities
   ∞ - Quantum entanglement
   ▪·˙ - Virtual particle fluctuations
   ║▀▄▓ - Gateway structure with uncertainty
       
       /\        /\
      /  \    /  \ 
     /    \  /    \ 
    /      \/      \ 
                ◉
  -->
<html>
<head>
    <meta charset="UTF-8">
    <title>Quantum Gateway - Enhanced Quantum Mechanics</title>
    <style>        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #canvas {
            white-space: pre;
            line-height: 1.1;
        }        .energy-low { color: #002200; }
        .energy-med { color: #004400; }
        .energy-high { color: #00aa00; }
        .energy-peak { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .portal-core { color: #ffffff; text-shadow: 0 0 10px #00ffff; }
        .dimensional { color: #ff44ff; text-shadow: 0 0 6px #ff00ff; }
        .quantum-flux { color: #ffaa00; text-shadow: 0 0 4px #ffff00; }
        .void-space { color: #000044; text-shadow: 0 0 3px #000088; }
        .void-deep { color: #000000; background: #000044; }
        .gateway-frame { color: #00aaff; text-shadow: 0 0 3px #00ffff; }
        .gateway-stable { color: #0088ff; text-shadow: 0 0 2px #0088ff; }
        .rift-edge { color: #8800ff; text-shadow: 0 0 8px #ff00ff; }
        .spacetime { color: #666666; }
    </style>
</head>
<body>
<pre id="canvas"></pre>
<div id="status" style="position: absolute; top: 10px; left: 10px; color: #00ff00; font-size: 12px;">
    Gateway Status: <span id="phase">Initializing</span><br>
    Energy Level: <span id="energy">0%</span><br>
    Resonance: <span id="resonance">Stabilizing</span>
</div>
<script>
(function() {
    const width = 60;
    const height = 25;
    const center = Math.floor(width / 2);
    const archRadius = 20;
    let t = 0;
    let gatewayPhase = 0; // 0=charging, 1=resonance, 2=opening, 3=stable, 4=portal
    let energyLevel = 0;
    let phaseTimer = 0;
    
    // Quantum constants and parameters
    const hbar = 1.0546e-34;
    const mass = 9.109e-31;
    const k = 2 * Math.PI / 10;
    const omega = 3.14;
    
    // Gateway activation parameters
    let portalRadius = 0;
    let dimensionalLayers = 0;
    let resonanceFreq = 1.0;
    
    // Color and character mapping
    function getCharWithColor(char, colorClass) {
        return `<span class="${colorClass}">${char}</span>`;
    }
      // Complex wave function with stable gateway geometry
    function calculateQuantumField(x, y, t, phase) {
        const r = Math.sqrt((x - center) ** 2 + (y - height/2) ** 2);
        const theta = Math.atan2(y - height/2, x - center);
        
        // Stable energy buildup based on gateway phase
        const energyFactor = Math.min(energyLevel / 100, 1.0);
        const stabilizedPhase = Math.sin(t * resonanceFreq * 0.7 + r * 0.15) * energyFactor;
        
        // Multi-dimensional portal layers with depth
        const portalDepth = phase >= 2 ? Math.exp(-Math.pow(r - portalRadius, 2) / 40) : 0;
        const riftDepth = Math.floor(portalDepth * 5); // 5 depth layers
        
        // Dimensional membrane oscillation
        const membraneRipple = Math.sin(theta * 4 + t * 0.2) * Math.cos(r * 0.3 + t * 0.15);
        
        // Spacetime curvature around portal
        const curvature = phase >= 3 ? 1 / (1 + Math.pow(r - portalRadius, 2) * 0.1) : 0;
        
        // Quantum tunneling through dimensional barriers
        const tunnelField = Math.exp(-Math.abs(r - portalRadius) * (2 - energyFactor));
        
        // Stabilized wave components
        const waveReal = stabilizedPhase * Math.cos(k * r - omega * t * 0.08) * tunnelField;
        const waveImag = stabilizedPhase * Math.sin(k * r - omega * t * 0.08) * tunnelField;
        
        const probability = waveReal * waveReal + waveImag * waveImag + curvature;
        
        return { 
            real: waveReal, 
            imag: waveImag, 
            prob: probability,
            portal: portalDepth,
            depth: riftDepth,
            membrane: membraneRipple,
            curvature: curvature
        };
    }
    
    // Gateway phase management
    function updateGatewayPhase() {
        phaseTimer++;
        
        switch(gatewayPhase) {
            case 0: // Charging
                energyLevel = Math.min(energyLevel + 0.8, 30);
                if (energyLevel >= 30) { gatewayPhase = 1; phaseTimer = 0; }
                break;
            case 1: // Resonance Building
                energyLevel = Math.min(energyLevel + 0.5, 60);
                resonanceFreq = 1.0 + Math.sin(t * 0.1) * 0.5;
                if (energyLevel >= 60) { gatewayPhase = 2; phaseTimer = 0; }
                break;
            case 2: // Opening
                energyLevel = Math.min(energyLevel + 0.3, 85);
                portalRadius = Math.min(portalRadius + 0.15, 8);
                dimensionalLayers = Math.min(dimensionalLayers + 0.05, 3);
                if (energyLevel >= 85 && portalRadius >= 7) { gatewayPhase = 3; phaseTimer = 0; }
                break;
            case 3: // Stabilizing
                energyLevel = Math.min(energyLevel + 0.1, 95);
                portalRadius = 8 + Math.sin(t * 0.2) * 0.5;
                if (energyLevel >= 95) { gatewayPhase = 4; phaseTimer = 0; }
                break;
            case 4: // Stable Portal
                energyLevel = 100;
                portalRadius = 8 + Math.sin(t * 0.15) * 1.0;
                dimensionalLayers = 3 + Math.cos(t * 0.1) * 0.5;
                break;
        }
    }
    
    // Status updates
    function updateStatus() {
        const phases = ['Charging', 'Resonance Building', 'Opening', 'Stabilizing', 'Portal Active'];
        const resonances = ['Building', 'Harmonizing', 'Syncing', 'Locked', 'Stable'];
        
        document.getElementById('phase').textContent = phases[gatewayPhase];
        document.getElementById('energy').textContent = Math.floor(energyLevel) + '%';
        document.getElementById('resonance').textContent = resonances[gatewayPhase];
    }

    function render() {
        updateGatewayPhase();
        updateStatus();
        
        let output = '';
          // Render the quantum gateway
        for (let y = 0; y < height; y++) {
            const yNorm = y / (height - 2);
            const sinTerm = Math.sin(yNorm * Math.PI / 2);
            // Fixed pillar positions - no movement
            const leftX = Math.floor(center - archRadius * sinTerm);
            const rightX = Math.floor(center + archRadius * sinTerm);
            
            for (let x = 0; x < width; x++) {
                let ch = ' ';
                let colorClass = '';
                
                // Calculate quantum field at this position
                const field = calculateQuantumField(x, y, t, gatewayPhase);
                const distFromCenter = Math.sqrt((x - center) ** 2 + (y - height/2) ** 2);
                const isInsideGateway = (x > leftX && x < rightX && y < height - 1);
                
                // Stable Gateway Structure - NEVER MOVES
                if (y === height - 1) {
                    ch = '▄';
                    colorClass = 'gateway-frame';
                } else if (x === leftX || x === rightX) {
                    // Stable pillars with energy visualization
                    if (energyLevel > 80) {
                        ch = '║';
                        colorClass = 'gateway-stable';
                    } else if (energyLevel > 50) {
                        ch = '│';
                        colorClass = 'gateway-frame';
                    } else {
                        ch = '│';
                        colorClass = 'spacetime';
                    }
                }
                
                // Enhanced Quantum Keystone
                if (y === 1 && x === center) {
                    if (gatewayPhase >= 4) {
                        ch = Math.sin(t * 0.3) > 0.5 ? '◉' : '⬟';
                        colorClass = 'portal-core';
                    } else if (gatewayPhase >= 3) {
                        ch = Math.sin(t * 0.4) > 0 ? '◎' : '◉';
                        colorClass = 'energy-peak';
                    } else if (gatewayPhase >= 1) {
                        ch = '○';
                        colorClass = 'energy-high';
                    } else {
                        ch = '·';
                        colorClass = 'energy-low';
                    }
                }
                
                // Multi-Dimensional Portal Interior
                if (isInsideGateway) {
                    const portal = field.portal;
                    const depth = field.depth;
                    const membrane = field.membrane;
                    const curvature = field.curvature;
                    
                    // True dimensional rift with depth layers
                    if (gatewayPhase >= 4 && distFromCenter <= portalRadius) {
                        
                        // Depth-based portal visualization
                        if (depth >= 4) { // Deepest void
                            ch = '●';
                            colorClass = 'void-deep';
                        } else if (depth >= 3) { // Deep space
                            ch = '◉';
                            colorClass = 'void-space';
                        } else if (depth >= 2) { // Mid-dimensional layer
                            ch = membrane > 0.3 ? '◊' : '◈';
                            colorClass = 'dimensional';
                        } else if (depth >= 1) { // Surface dimensional layer
                            ch = '◌';
                            colorClass = 'rift-edge';
                        } else { // Portal edge with curvature
                            ch = curvature > 0.5 ? '○' : '◯';
                            colorClass = 'portal-core';
                        }
                        
                        // Membrane oscillations
                        if (Math.abs(membrane) > 0.7 && depth >= 2) {
                            ch = '≋';
                            colorClass = 'dimensional';
                        }
                    }
                    // Portal Opening Sequence
                    else if (gatewayPhase >= 2 && distFromCenter <= portalRadius + 3) {
                        if (portal > 0.8) {
                            ch = '⚡';
                            colorClass = 'quantum-flux';
                        } else if (portal > 0.6) {
                            ch = field.membrane > 0 ? '✦' : '✧';
                            colorClass = 'energy-peak';
                        } else if (portal > 0.4) {
                            ch = '◆';
                            colorClass = 'energy-high';
                        } else if (portal > 0.2) {
                            ch = '◇';
                            colorClass = 'energy-med';
                        }
                    }
                    // Base energy field
                    else {
                        const prob = field.prob;
                        if (prob > 1.2) {
                            ch = '▪';
                            colorClass = 'energy-high';
                        } else if (prob > 0.6) {
                            ch = '·';
                            colorClass = 'energy-med';
                        } else if (prob > 0.2) {
                            ch = '˙';
                            colorClass = 'energy-low';
                        }
                    }
                    
                    // Quantum entanglement streams (stable)
                    if (gatewayPhase >= 3 && Math.abs(field.membrane) > 0.85 && distFromCenter > portalRadius + 1) {
                        ch = '∞';
                        colorClass = 'dimensional';
                    }
                }
                
                // Gateway arch top - stable with energy patterns
                if (y === 0 && x >= leftX && x <= rightX) {
                    const archPattern = Math.sin((x - leftX) * 0.4 + t * 0.2);
                    if (energyLevel > 70 && archPattern > 0.3) {
                        ch = '▓';
                        colorClass = 'energy-peak';
                    } else {
                        ch = '▀';
                        colorClass = 'gateway-stable';
                    }
                }
                
                // Apply color and add to output
                // ...existing code...
                if (colorClass) {
                    output += getCharWithColor(ch, colorClass);
                } else {
                    output += ch;
                }
            }
            output += '\n';
        }
        
        document.getElementById('canvas').innerHTML = output;
        t += 0.1;
        requestAnimationFrame(render);
    }
    
    render();
})();
</script>
</body>
</html>
